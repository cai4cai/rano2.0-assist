

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>utils.measurements2D_utils &mdash; RANO2.0-assist  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            RANO2.0-assist
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">RANO2.0-assist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RANO2.0-assist</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">utils.measurements2D_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for utils.measurements2D_utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the Measurements2DMixin class, which is used to perform 2D measurements on</span>
<span class="sd">lesions in medical images. The class provides methods for calculating, displaying, and managing</span>
<span class="sd">lesion measurements, as well as handling user interactions with the GUI.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">functools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">nibabel.orientations</span><span class="w"> </span><span class="kn">import</span> <span class="n">aff2axcodes</span><span class="p">,</span> <span class="n">io_orientation</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">qt</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">slicer</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">vtk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">response_classification_utils</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">slicer.util</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">utils.ui_helper_utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ui_helper_utils</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">utils.results_table_utils</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">results_table_utils</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">utils.rano_utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_instance_segmentation_by_connected_component_analysis</span><span class="p">,</span> \
    <span class="n">match_instance_segmentations_by_IoU</span><span class="p">,</span> <span class="n">get_max_orthogonal_line_product_coords</span><span class="p">,</span> \
    <span class="n">get_ijk_to_world_matrix</span><span class="p">,</span> <span class="n">transform_world_to_ijk_coord</span><span class="p">,</span> <span class="n">transform_ijk_to_world_coord</span><span class="p">,</span> \
    <span class="n">point_closest_to_two_lines</span><span class="p">,</span> <span class="n">circle_opening_on_slices_perpendicular_to_axis</span><span class="p">,</span> <span class="n">sphere_opening</span><span class="p">,</span> <span class="n">find_closest_plane</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">utils.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">debug</span>


<div class="viewcode-block" id="Measurements2DMixin">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Measurements2DMixin</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This mixin class provides methods for performing 2D measurements on lesions in medical images.</span>
<span class="sd">    It includes methods for calculating, displaying, and managing lesion measurements, as well as</span>
<span class="sd">    handling user interactions with the GUI.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameterNode</span><span class="p">,</span> <span class="n">ui</span><span class="p">,</span> <span class="n">lineNodePairs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parameterNode</span> <span class="o">=</span> <span class="n">parameterNode</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The parameter node of the module. This node stores all user choices in parameter values, node selections, etc.</span>
<span class="sd">        so that when the scene is saved and reloaded, these settings are restored.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ui</span> <span class="o">=</span> <span class="n">ui</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The UI elements of the module. This is a dictionary containing all the widgets in the module.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span> <span class="o">=</span> <span class="n">lineNodePairs</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of line node pairs used for 2D measurements.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">instance_segmentations_matched</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of instance segmentations (numpy arrays) with matching labels across time points.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resampledSegNodes</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of segmentation nodes (vtkMRMLSegmentationNode) containing the matched instance segmentations.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">resampledVolumeNodes</span> <span class="o">=</span> <span class="kc">None</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of instance segmentations (vtkMRMLLabelMapVolumeNode) transformed and resampled to the reference input volume space.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_orientation</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary to store the orientation of the lesions in the previous timepoint to enable consistent 2D measurement orientation across timepoints.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_center</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary to store the center of the lesions in the previous timepoint to enable consistent 2D measurement slices across timepoints.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store observers for the line nodes to handle user interactions.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Store observers for the line nodes to handle user interactions.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Measurements2DMixin.onCalc2DButton">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.onCalc2DButton">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">onCalc2DButton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the &quot;Calculate 2D&quot; button is pressed.</span>

<span class="sd">        It performs the following steps:</span>
<span class="sd">        1. Get the selected segmentations and instance segmentations.</span>
<span class="sd">        2. Match the instance segmentations across timepoints.</span>
<span class="sd">        3. Transform and resample the instance segmentations in the original reference image space.</span>
<span class="sd">        4. For each timepoint and lesion, place the RANO lines.</span>
<span class="sd">        5. Evaluate the 2D measurements and store the results in a dictionary.</span>
<span class="sd">        6. Display the results in the UI.</span>
<span class="sd">        7. Update the line pair UI list.</span>
<span class="sd">        8. Calculate the results table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Calc 2D button pressed&quot;</span><span class="p">)</span>

        <span class="c1"># determine the method to use for 2D measurements</span>
        <span class="n">method2DmeasComboBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">method2DmeasComboBox</span><span class="o">.</span><span class="n">currentText</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_lineNodePairs</span><span class="p">(</span><span class="n">lesion_stats</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            From line coordinates stored in lesion_stats, create lineNodePairs that are used to display the lines in the</span>
<span class="sd">            UI views.</span>

<span class="sd">            Args:</span>
<span class="sd">                lesion_stats: dictionary containing the line coordinates for each lesion and timepoint</span>
<span class="sd">            Returns:</span>
<span class="sd">                lineNodePairs: LineNodePairList containing the line node pairs for each lesion and timepoint</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lineNodePairs</span> <span class="o">=</span> <span class="n">LineNodePairList</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">les_idx</span> <span class="ow">in</span> <span class="n">lesion_stats</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">tp</span> <span class="ow">in</span> <span class="n">lesion_stats</span><span class="p">[</span><span class="n">les_idx</span><span class="p">]:</span>
                    <span class="n">coords</span> <span class="o">=</span> <span class="n">lesion_stats</span><span class="p">[</span><span class="n">les_idx</span><span class="p">][</span><span class="n">tp</span><span class="p">][</span><span class="s2">&quot;coords&quot;</span><span class="p">]</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">lineNodePair</span> <span class="o">=</span> <span class="n">LineNodePair</span><span class="p">(</span><span class="n">lesion_idx</span><span class="o">=</span><span class="n">les_idx</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="n">tp</span><span class="p">)</span>
                    <span class="n">lineNodePair</span><span class="o">.</span><span class="n">set_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                    <span class="n">lineNodePairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lineNodePair</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">lineNodePairs</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">setLinePairViews</span><span class="p">(</span><span class="n">lineNodePairs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Set the views for the line node pairs in the UI, i.e. it will make sure that lines of timepoint1 are shown in</span>
<span class="sd">            the timepoint1 views and lines of timepoint2 are shown in the timepoint2 views.</span>

<span class="sd">            It will also center the views of each timepoint on the first available line node pair in the list.</span>
<span class="sd">            Args:</span>
<span class="sd">                lineNodePairs: LineNodePairList containing the line node pairs for each lesion and timepoint</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">tp_view_set</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># keep track of which timepoint views have already been set</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">lineNodePairs</span><span class="p">:</span>
                <span class="n">les_idx</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span>

                <span class="c1"># make sure the line node pair is displayed in the correct view</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setViews</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>

                <span class="c1"># center on the first available line node pair in the list</span>
                <span class="k">if</span> <span class="n">tp</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tp_view_set</span><span class="p">:</span>  <span class="c1"># to set views for this timepoint only once</span>
                    <span class="n">tp_view_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">centerTimepointViewsOnCenterPoint</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_binary_semantic_segmentations</span><span class="p">(</span><span class="n">segNodes</span><span class="p">,</span> <span class="n">segmentId</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Extract the binary semantic segmentations of a segment from the segmentation nodes as numpy arrays.</span>

<span class="sd">            Args:</span>
<span class="sd">                segNodes: list of segmentation nodes for each time point</span>
<span class="sd">                segmentId: ID of the segment to extract</span>
<span class="sd">            Returns:</span>
<span class="sd">                binary_semantic_segmentations: list of binary semantic segmentations of the segment (numpy arrays)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">binary_semantic_segmentations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">segNodes</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">CreateBinaryLabelmapRepresentation</span><span class="p">()</span>
                <span class="n">refVol</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">GetNodeReference</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">vtkMRMLSegmentationNode</span><span class="o">.</span><span class="n">GetReferenceImageGeometryReferenceRole</span><span class="p">())</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">segmentId</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegmentIDs</span><span class="p">():</span>
                    <span class="c1"># if the segmentId does not exist, we want an empty binary segmentation (all zeros)</span>
                    <span class="n">bin_sem_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">arrayFromVolume</span><span class="p">(</span><span class="n">refVol</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bin_sem_seg</span> <span class="o">=</span> <span class="n">arrayFromVolume</span><span class="p">(</span><span class="n">refVol</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="n">segmentId</span><span class="p">)</span>

                <span class="n">binary_semantic_segmentations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_sem_seg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">binary_semantic_segmentations</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_instance_segmentations</span><span class="p">(</span><span class="n">binary_segmentations</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Convert the binary segmentations to instance segmentations.</span>
<span class="sd">            Currently, this is done by connected component analysis.</span>
<span class="sd">            Args:</span>
<span class="sd">                binary_segmentations: list of binary segmentations (numpy arrays)</span>
<span class="sd">            Returns:</span>
<span class="sd">                instance_segmentations: list of instance segmentations (numpy arrays) for each time point. Note that at</span>
<span class="sd">                the moment, the instance segmentations are not matched across time points, i.e., the labels do not</span>
<span class="sd">                correspond to the same instance across time points.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">instance_segmentations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">binary_segmentations</span><span class="p">:</span>
                <span class="n">instance_seg</span> <span class="o">=</span> <span class="n">get_instance_segmentation_by_connected_component_analysis</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
                <span class="n">instance_segmentations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">instance_segmentations</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">matched_instances_across_timepoints</span><span class="p">(</span><span class="n">instance_segmentations</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Match the instance segmentations across time points. For example, as an output, if the first timepoint</span>
<span class="sd">            has instances 1, 2, 3 and the second timepoint can have instance 1, 3, 4 then instance 2 is missing in</span>
<span class="sd">            the second timepoint (disappeared) and instance 4 is a new instance in the second timepoint.</span>

<span class="sd">            Args:</span>
<span class="sd">                instance_segmentations: list of instance segmentations (numpy arrays) for each time point</span>
<span class="sd">            Returns:</span>
<span class="sd">                instance_segmentations_matched: list of instance segmentations (numpy arrays) with matching labels across</span>
<span class="sd">                time points.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">instance_segmentations_matched</span> <span class="o">=</span> <span class="n">match_instance_segmentations_by_IoU</span><span class="p">(</span><span class="n">instance_segmentations</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">instance_segmentations_matched</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">transform_to_and_resample_in_original_img_space</span><span class="p">(</span><span class="n">instance_segmentations_matched</span><span class="p">,</span> <span class="n">segNodes</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The instance_segmentations_matched need to be transformed and resampled in the reference spaces, i.e.,</span>
<span class="sd">            seg1 to the reference space of timepoint1 and seg2 to the reference space of timepoint2. This is so that the</span>
<span class="sd">            RANO lines can be placed on slices of the original input volumes.</span>
<span class="sd">            Currently, the reference space are given by the channel1 input volumes, but this can be changed in the future.</span>
<span class="sd">            This means, the RANO lines are placed on slices of the channel1 input volumes (reference space).</span>

<span class="sd">            Steps:</span>
<span class="sd">            1. Create a segmentation node for each instance segmentation and place instance segments in there.</span>
<span class="sd">               Then apply the transform to the segmentation node. This will give a segmentation node in the original space,</span>
<span class="sd">               but with spacing 1x1x1.</span>
<span class="sd">            2. Resample the image to the original reference input volume space.</span>

<span class="sd">            Args:</span>
<span class="sd">                instance_segmentations_matched: list of instance segmentations (numpy arrays) with matching labels across time points</span>
<span class="sd">                segNodes: list of segmentation nodes for each time point</span>

<span class="sd">            Returns:</span>
<span class="sd">                resampledVolumeNodes: list of vtkMRMLLabelMapVolumeNode objects with the resampled instance segmentations</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instance_segmentations_matched</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">segNodes</span><span class="p">)),</span> <span class="s2">&quot;Number of instance segmentations and segmentation nodes must be equal&quot;</span>
            <span class="n">num_timepoints</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">segNodes</span><span class="p">)</span>

            <span class="c1"># get the transforms and reference volumes for each timepoint (currently only channel1)</span>
            <span class="n">transformNodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transform_timepoint</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">_channel1 (-)&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_timepoints</span><span class="p">)]</span>
            <span class="n">referenceVolumeNodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_parameterNode</span><span class="o">.</span><span class="n">GetNodeReference</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;InputVolume_channel1_t</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_timepoints</span><span class="p">)]</span>

            <span class="n">resampledSegNodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">resampledVolumeNodes</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">segNode</span><span class="p">,</span> <span class="n">transformNode</span><span class="p">,</span> <span class="n">referenceVolumeNode</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">instance_segmentations_matched</span><span class="p">,</span> <span class="n">segNodes</span><span class="p">,</span> <span class="n">transformNodes</span><span class="p">,</span> <span class="n">referenceVolumeNodes</span><span class="p">)):</span>
                <span class="c1"># new segmentation node to store the matched instance segmentations</span>
                <span class="n">newSegNodeName</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;matched_instance_segmentation_t</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="c1"># if the segmentation node already exists, remove it</span>
                <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">newSegNodeName</span><span class="p">):</span>
                    <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">newSegNodeName</span><span class="p">))</span>
                <span class="n">newSegNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">AddNewNodeByClass</span><span class="p">(</span><span class="s2">&quot;vtkMRMLSegmentationNode&quot;</span><span class="p">,</span>
                                                                <span class="sa">f</span><span class="s2">&quot;matched_instance_segmentation_t</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="n">referenceImageVolumeNode</span> <span class="o">=</span> <span class="n">segNode</span><span class="o">.</span><span class="n">GetNodeReference</span><span class="p">(</span><span class="s1">&#39;referenceImageGeometryRef&#39;</span><span class="p">)</span>
                <span class="n">newSegNode</span><span class="o">.</span><span class="n">SetReferenceImageGeometryParameterFromVolumeNode</span><span class="p">(</span><span class="n">referenceImageVolumeNode</span><span class="p">)</span>

                <span class="c1"># add the segmentations to the new segmentation node</span>
                <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">lab</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>

                    <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">updateSegmentBinaryLabelmapFromArray</span><span class="p">(</span><span class="n">narray</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seg</span> <span class="o">==</span> <span class="n">lab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">),</span>
                                                                     <span class="n">segmentationNode</span><span class="o">=</span><span class="n">newSegNode</span><span class="p">,</span>
                                                                     <span class="n">segmentId</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">),</span>
                                                                     <span class="n">referenceVolumeNode</span><span class="o">=</span><span class="n">referenceImageVolumeNode</span>
                                                                     <span class="p">)</span>
                    <span class="c1"># set the name of the new segment as Les 1, Les 2, etc.</span>
                    <span class="n">newSegNode</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegment</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">lab</span><span class="p">))</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Les </span><span class="si">{</span><span class="n">lab</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># render in 3D</span>
                <span class="n">newSegNode</span><span class="o">.</span><span class="n">CreateClosedSurfaceRepresentation</span><span class="p">()</span>

                <span class="c1"># make sure there is a displayNode</span>
                <span class="n">newSegNode</span><span class="o">.</span><span class="n">CreateDefaultDisplayNodes</span><span class="p">()</span>

                <span class="c1"># display the segmentations on the corresponding views only</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">setViews</span><span class="p">(</span><span class="n">newSegNode</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;timepoint</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># hide the old and new segmentation nodes since we want to show the resampled labelmap volumes instead</span>
                <span class="n">segNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">newSegNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

                <span class="c1"># apply the transform to the new segmentation node</span>
                <span class="k">if</span> <span class="n">transformNode</span><span class="p">:</span>
                    <span class="n">newSegNode</span><span class="o">.</span><span class="n">SetAndObserveTransformNodeID</span><span class="p">(</span><span class="n">transformNode</span><span class="o">.</span><span class="n">GetID</span><span class="p">())</span>

                <span class="c1"># 2. resample the segmentation to the original input volume space</span>
                <span class="c1"># get all segmentIds from the new segmentation node</span>
                <span class="n">segmentIds</span> <span class="o">=</span> <span class="n">newSegNode</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegmentIDs</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">segmentIds</span><span class="p">:</span>
                    <span class="c1"># create new labelmap volume node</span>
                    <span class="n">newLabelMapVolumeName</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;matched_instance_segmentation_t</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">_resampled&quot;</span>
                    <span class="c1"># if it already exists, remove it</span>
                    <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">newLabelMapVolumeName</span><span class="p">):</span>
                        <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">newLabelMapVolumeName</span><span class="p">))</span>
                    <span class="n">labelmapVolumeNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">AddNewNodeByClass</span><span class="p">(</span><span class="s2">&quot;vtkMRMLLabelMapVolumeNode&quot;</span><span class="p">,</span>
                                                                            <span class="n">newLabelMapVolumeName</span><span class="p">)</span>

                    <span class="n">slicer</span><span class="o">.</span><span class="n">vtkSlicerSegmentationsModuleLogic</span><span class="o">.</span><span class="n">ExportSegmentsToLabelmapNode</span><span class="p">(</span><span class="n">newSegNode</span><span class="p">,</span>
                                                                                          <span class="n">segmentIds</span><span class="p">,</span>
                                                                                          <span class="n">labelmapVolumeNode</span><span class="p">,</span>
                                                                                          <span class="n">referenceVolumeNode</span><span class="p">)</span>

                    <span class="c1"># set the views</span>
                    <span class="n">ui_helper_utils</span><span class="o">.</span><span class="n">UIHelperMixin</span><span class="o">.</span><span class="n">setLabelVolumes</span><span class="p">(</span><span class="n">labelmapVolumeNode</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;timepoint</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No segments found in </span><span class="si">{</span><span class="n">newSegNode</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="n">labelmapVolumeNode</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="n">resampledSegNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newSegNode</span><span class="p">)</span>
                <span class="n">resampledVolumeNodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">labelmapVolumeNode</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">resampledSegNodes</span> <span class="o">=</span> <span class="n">resampledSegNodes</span>
            <span class="k">return</span> <span class="n">resampledVolumeNodes</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">open_instance_segmentation</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Open the instance segmentation using the method specified in the method2DmeasComboBox.</span>

<span class="sd">            Args:</span>
<span class="sd">                instance_seg: instance segmentation (numpy array)</span>
<span class="sd">                radius: radius of the opening operation</span>
<span class="sd">            Returns:</span>
<span class="sd">                seg_open: opened instance segmentation (numpy array)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">seg_open</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lab</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">method2DmeasComboBox</span> <span class="o">==</span> <span class="s2">&quot;RANO_open2D&quot;</span><span class="p">:</span>
                    <span class="n">seg_open</span> <span class="o">+=</span> <span class="n">lab</span> <span class="o">*</span> <span class="n">circle_opening_on_slices_perpendicular_to_axis</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">,</span>
                                                                                     <span class="n">axes</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                                                                                     <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">lab</span><span class="p">],</span>
                                                                                     <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                                                                    <span class="p">)</span>
                <span class="k">elif</span> <span class="n">method2DmeasComboBox</span> <span class="o">==</span> <span class="s2">&quot;RANO_open3D&quot;</span><span class="p">:</span>
                    <span class="n">seg_open</span> <span class="o">+=</span> <span class="n">lab</span> <span class="o">*</span> <span class="n">sphere_opening</span><span class="p">(</span><span class="n">instance_seg</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="n">lab</span><span class="p">],</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;No implementation available for opening the segmentations with method </span><span class="si">{</span><span class="n">method2DmeasComboBox</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">seg_open</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">open_instance_segmentations</span><span class="p">(</span><span class="n">instance_segmentations</span><span class="p">,</span> <span class="n">opening_radius</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Loop over the instance segmentations and perform morphological opening on each segmentation.</span>

<span class="sd">            Args:</span>
<span class="sd">                instance_segmentations: list of instance segmentations (numpy arrays)</span>
<span class="sd">                opening_radius: radius of the opening operation</span>
<span class="sd">            Returns:</span>
<span class="sd">                opened_segmentations: list of opened instance segmentations (numpy arrays)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># open the segmentations</span>
            <span class="n">opened_segmentations</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">seg</span> <span class="ow">in</span> <span class="n">instance_segmentations</span><span class="p">:</span>
                <span class="n">opened_seg</span> <span class="o">=</span> <span class="n">open_instance_segmentation</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">opening_radius</span><span class="p">)</span>
                <span class="n">opened_segmentations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">opened_seg</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">opened_segmentations</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">evaluate_instance_segmentation</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evaluate the instance segmentation. Specifically, retrieve the coordinates of the 2D measurements considering the</span>
<span class="sd">            specified options (orientation, slice consistency, etc.) and the method selected in the UI.</span>
<span class="sd">            Also, calculate the volume of the lesions.</span>

<span class="sd">            Args:</span>
<span class="sd">                resampledVolumeNode: vtkMRMLLabelMapVolumeNode containing the matched instance segmentation.</span>

<span class="sd">            Returns:</span>
<span class="sd">                lesion_dict: dictionary containing the line pair coordinates and volume of each lesion for the current timepoint.</span>

<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lesion_dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="p">[],</span> <span class="s2">&quot;volume&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">})</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">resampledVolumeNode</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;resampledVolumeNode is None. Assuming no lesions for this timepoint.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">lesion_dict</span>

            <span class="n">instance_segmentation</span> <span class="o">=</span> <span class="n">arrayFromVolume</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">lab</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">instance_segmentation</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">lab</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># skip background label</span>
                    <span class="k">continue</span>
                <span class="n">bin_seg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">instance_segmentation</span> <span class="o">==</span> <span class="n">lab</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">method2DmeasComboBox</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;RANO&quot;</span><span class="p">,</span> <span class="s2">&quot;RANO_open2D&quot;</span><span class="p">,</span> <span class="s2">&quot;RANO_open3D&quot;</span><span class="p">]:</span>

                    <span class="c1"># store the orientation of the lesion in the current timepoint</span>
                    <span class="n">orientation_consistency_across_timepoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameterNode</span><span class="o">.</span><span class="n">GetParameter</span><span class="p">(</span><span class="s2">&quot;orient_cons_tp&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                    <span class="n">previous_timepoint_orientation_current_lesion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_orientation</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">orientation_consistency_across_timepoints</span> <span class="ow">and</span> <span class="n">previous_timepoint_orientation_current_lesion</span><span class="p">:</span>
                        <span class="n">valid_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">previous_timepoint_orientation_current_lesion</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">valid_orientations</span> <span class="o">=</span> <span class="p">[</span><span class="n">orien</span> <span class="k">for</span> <span class="n">orien</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sagittal&quot;</span><span class="p">,</span> <span class="s2">&quot;coronal&quot;</span><span class="p">,</span> <span class="s2">&quot;axial&quot;</span><span class="p">]</span> <span class="k">if</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_parameterNode</span><span class="o">.</span><span class="n">GetParameter</span><span class="p">(</span><span class="n">orien</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">]</span>

                    <span class="c1"># store the slice number of the lesion in the current timepoint</span>
                    <span class="n">force_close_slice_across_timepoints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parameterNode</span><span class="o">.</span><span class="n">GetParameter</span><span class="p">(</span><span class="s2">&quot;same_slc_tp&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span>
                    <span class="n">center_IJK</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">force_close_slice_across_timepoints</span> <span class="ow">and</span> <span class="n">previous_timepoint_orientation_current_lesion</span><span class="p">:</span>
                        <span class="n">previous_timepoint_center_current_lesion</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_center</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">lab</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                        <span class="n">center_world</span> <span class="o">=</span> <span class="n">previous_timepoint_center_current_lesion</span>
                        <span class="c1"># need to convert world center point to IJK point</span>
                        <span class="n">worldToIJK</span> <span class="o">=</span> <span class="n">get_ijk_to_world_matrix</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">)</span>
                        <span class="n">worldToIJK</span><span class="o">.</span><span class="n">Invert</span><span class="p">()</span>

                        <span class="n">center_IJK</span> <span class="o">=</span> <span class="n">transform_world_to_ijk_coord</span><span class="p">(</span><span class="n">center_world</span><span class="p">,</span> <span class="n">worldToIJK</span><span class="p">)</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_IJK_axis</span><span class="p">(</span><span class="n">orientation</span><span class="p">,</span> <span class="n">resampledVolumeNode</span><span class="p">):</span>
<span class="w">                        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                        Convert the anatomical orientation to the corresponding IJK axis index using the IJK to RAS matrix.</span>

<span class="sd">                        Args:</span>
<span class="sd">                            orientation: anatomical orientation (&quot;sagittal&quot;, &quot;coronal&quot;, &quot;axial&quot;)</span>
<span class="sd">                            resampledVolumeNode: vtkMRMLLabelMapVolumeNode containing the matched instance segmentations</span>
<span class="sd">                        Returns:</span>
<span class="sd">                            ijk_axis_idx: IJK axis index corresponding to the anatomical orientation</span>
<span class="sd">                        &quot;&quot;&quot;</span>

                        <span class="c1"># mapping from anatomical orientations to anatomical axis indices in 3D slicer (RAS)</span>
                        <span class="n">orientation_to_world_axis_idx</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;sagittal&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;coronal&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;axial&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
                        <span class="n">world_axis_idx</span> <span class="o">=</span> <span class="n">orientation_to_world_axis_idx</span><span class="p">[</span><span class="n">orientation</span><span class="p">]</span>  <span class="c1"># get the current world axis index</span>

                        <span class="c1"># get the RAS to IJK matrix</span>
                        <span class="n">ijkToWorld</span> <span class="o">=</span> <span class="n">get_ijk_to_world_matrix</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">)</span>
                        <span class="n">ijkToWorld</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">arrayFromVTKMatrix</span><span class="p">(</span><span class="n">ijkToWorld</span><span class="p">)</span>
                        <span class="n">worldToIJK</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">ijkToWorld</span><span class="p">)</span>

                        <span class="c1"># convert from world axis index to IJK axis index</span>
                        <span class="n">ornt</span> <span class="o">=</span> <span class="n">io_orientation</span><span class="p">(</span><span class="n">worldToIJK</span><span class="p">)</span>  <span class="c1"># mapping from RAS axes to IJK axes</span>
                        <span class="n">ijk_axis_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ornt</span><span class="p">[</span><span class="n">world_axis_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># [0] picks the corresponding axis in the IJK space ([1] picks the direction)</span>

                        <span class="k">return</span> <span class="n">ijk_axis_idx</span>

                    <span class="c1"># need to convert world orientation to IJK axis</span>
                    <span class="n">valid_axes_IJK</span> <span class="o">=</span> <span class="p">[</span><span class="n">convert_to_IJK_axis</span><span class="p">(</span><span class="n">orien</span><span class="p">,</span> <span class="n">resampledVolumeNode</span><span class="p">)</span> <span class="k">for</span> <span class="n">orien</span> <span class="ow">in</span> <span class="n">valid_orientations</span><span class="p">]</span>
                    <span class="c1"># need to go back to numpy order (KJI)</span>
                    <span class="n">ijk_axis_idx_to_kji</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>  <span class="c1"># convert 0 to 2 and 2 to 0 and leave 1 as is</span>
                    <span class="n">valid_axes_IJK</span> <span class="o">=</span> <span class="p">[</span><span class="n">ijk_axis_idx_to_kji</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">valid_axes_IJK</span><span class="p">]</span>

                    <span class="c1"># get the line pair coordinates for the current lesion</span>
                    <span class="n">coords_world</span> <span class="o">=</span> <span class="n">get_max_orthogonal_line_product_coords</span><span class="p">(</span><span class="n">bin_seg</span><span class="p">,</span> <span class="n">valid_axes_IJK</span><span class="p">,</span> <span class="n">center_IJK</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="o">=</span><span class="n">get_ijk_to_world_matrix</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">))</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_world</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">world_normal_axis_idx</span> <span class="o">=</span> <span class="n">find_closest_plane</span><span class="p">(</span><span class="n">coords_world</span><span class="p">)</span>
                        <span class="n">this_timepoint_orientation_curr_lesion</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s1">&#39;sagittal&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s1">&#39;coronal&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s1">&#39;axial&#39;</span><span class="p">}[</span><span class="n">world_normal_axis_idx</span><span class="p">]</span>

                        <span class="c1"># get the center of the line pair in IJK space to allow for consistent slice selection across timepoints</span>
                        <span class="n">center_world</span> <span class="o">=</span> <span class="n">point_closest_to_two_lines</span><span class="p">(</span><span class="n">coords_world</span><span class="p">)</span>
                        <span class="n">this_timepoint_center_world_curr_lesion</span> <span class="o">=</span> <span class="n">center_world</span>

                        <span class="c1"># store the orientation and center of the lesion in the current timepoint</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_orientation</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_timepoint_orientation_curr_lesion</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_center</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_timepoint_center_world_curr_lesion</span>

                    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">bin_seg</span><span class="p">)</span>

                <span class="k">elif</span> <span class="n">method2DmeasComboBox</span> <span class="o">==</span> <span class="s2">&quot;Random&quot;</span><span class="p">:</span>
                    <span class="n">coords_world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>  <span class="c1"># 2 lines, 2 points, 3 coordinates</span>
                    <span class="n">volume</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method </span><span class="si">{</span><span class="n">method2DmeasComboBox</span><span class="si">}</span><span class="s2"> not recognized&quot;</span><span class="p">)</span>

                <span class="n">lesion_dict</span><span class="p">[</span><span class="n">lab</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;coords&quot;</span><span class="p">:</span> <span class="n">coords_world</span><span class="p">,</span> <span class="s2">&quot;volume&quot;</span><span class="p">:</span> <span class="n">volume</span><span class="p">}</span>

            <span class="k">return</span> <span class="n">lesion_dict</span>


        <span class="k">def</span><span class="w"> </span><span class="nf">display_opened_segmentations</span><span class="p">(</span><span class="n">opened_segmentations</span><span class="p">,</span> <span class="n">segNodes</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The  opened segmentations (numpy arrays) are added to the segmentation nodes as new segments.</span>

<span class="sd">            Args:</span>
<span class="sd">                opened_segmentations: list of opened segmentations (numpy arrays)</span>
<span class="sd">                segNodes: list of segmentation nodes for each time point</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">segNode</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">opened_segmentations</span><span class="p">,</span> <span class="n">segNodes</span><span class="p">)):</span>

                <span class="n">nextSegmentId</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">segNode</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegmentIDs</span><span class="p">()))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

                <span class="c1"># temporarily apply transform to the reference image of the segmentation node</span>
                <span class="c1"># this is required because segNode itself has been transformed to the original image space, so the reference image</span>
                <span class="c1"># needs to be transformed to the original image space as well</span>
                <span class="n">transformNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNode</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Transform_timepoint</span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">_channel1 (-)&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">transformNode</span><span class="p">:</span>
                    <span class="n">referenceVolumeNode</span> <span class="o">=</span> <span class="n">segNode</span><span class="o">.</span><span class="n">GetNodeReference</span><span class="p">(</span><span class="s1">&#39;referenceImageGeometryRef&#39;</span><span class="p">)</span>
                    <span class="n">referenceVolumeNode</span><span class="o">.</span><span class="n">SetAndObserveTransformNodeID</span><span class="p">(</span><span class="n">transformNode</span><span class="o">.</span><span class="n">GetID</span><span class="p">())</span>

                <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">updateSegmentBinaryLabelmapFromArray</span><span class="p">(</span><span class="n">narray</span><span class="o">=</span><span class="n">seg</span><span class="p">,</span>
                                                                 <span class="n">segmentationNode</span><span class="o">=</span><span class="n">segNode</span><span class="p">,</span>
                                                                 <span class="n">segmentId</span><span class="o">=</span><span class="n">nextSegmentId</span><span class="p">,</span>
                                                                 <span class="n">referenceVolumeNode</span><span class="o">=</span><span class="n">segNode</span><span class="o">.</span><span class="n">GetNodeReference</span><span class="p">(</span>
                                                                     <span class="s1">&#39;referenceImageGeometryRef&#39;</span><span class="p">))</span>

                <span class="c1"># undo the transform of the reference image (we want to keep it in the segmentation model space to</span>
                <span class="c1"># avoid unnecessary resampling)</span>
                <span class="k">if</span> <span class="n">transformNode</span><span class="p">:</span>
                    <span class="n">referenceVolumeNode</span><span class="o">.</span><span class="n">SetAndObserveTransformNodeID</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

                <span class="c1"># set the name of the new segment</span>
                <span class="n">segmentIdSelectedForOpening</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">SegmentSelectorWidget</span><span class="o">.</span><span class="n">currentSegmentID</span><span class="p">()</span>
                <span class="n">segmentNameSelectedForOpening</span> <span class="o">=</span> <span class="n">segNode</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegment</span><span class="p">(</span><span class="n">segmentIdSelectedForOpening</span><span class="p">)</span><span class="o">.</span><span class="n">GetName</span><span class="p">()</span>
                <span class="n">segNode</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegment</span><span class="p">(</span><span class="n">nextSegmentId</span><span class="p">)</span><span class="o">.</span><span class="n">SetName</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">segmentNameSelectedForOpening</span><span class="si">}</span><span class="s2">_opened&quot;</span><span class="p">)</span>


        <span class="k">def</span><span class="w"> </span><span class="nf">get_lesion_stats</span><span class="p">(</span><span class="n">resampledVolumeNodes</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            For each timepoint, evaluate the instance segmentation and store the line pair coordinates and volume of the</span>
<span class="sd">            lesions in a dictionary.</span>

<span class="sd">            Args:</span>
<span class="sd">                resampledVolumeNodes: list of vtkMRMLLabelMapVolumeNode containing the matched instance segmentations</span>
<span class="sd">            Returns:</span>
<span class="sd">                lesion_stats: dictionary of dictionaries containing the line pair coordinates and volume of each lesion</span>
<span class="sd">                (key=lesion_idx) for each timepoint (key=timepoint).</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">lesion_stats</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="p">{}))</span>

            <span class="c1"># reset the previous timepoint orientation and center, so the previous run does not affect the current run</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_orientation</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">previous_timepoint_center</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">tp</span><span class="p">,</span> <span class="n">resampledVolumeNode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">resampledVolumeNodes</span><span class="p">):</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;timepoint</span><span class="si">{</span><span class="n">tp</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">lesion_dict_tp</span> <span class="o">=</span> <span class="n">evaluate_instance_segmentation</span><span class="p">(</span><span class="n">resampledVolumeNode</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">les_idx</span> <span class="ow">in</span> <span class="n">lesion_dict_tp</span><span class="p">:</span>
                    <span class="n">lesion_stats</span><span class="p">[</span><span class="n">les_idx</span><span class="p">][</span><span class="n">tp</span><span class="p">]</span> <span class="o">=</span> <span class="n">lesion_dict_tp</span><span class="p">[</span><span class="n">les_idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">lesion_stats</span>


        <span class="n">segNodes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">outputSelector</span><span class="o">.</span><span class="n">currentNode</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">outputSelector_t2</span><span class="o">.</span><span class="n">currentNode</span><span class="p">()]</span>

        <span class="n">binary_semantic_segmentations</span> <span class="o">=</span> <span class="n">get_binary_semantic_segmentations</span><span class="p">(</span><span class="n">segNodes</span><span class="p">,</span>
                                                                          <span class="n">segmentId</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">SegmentSelectorWidget</span><span class="o">.</span><span class="n">currentSegmentID</span><span class="p">())</span>

        <span class="n">instance_segmentations</span> <span class="o">=</span> <span class="n">get_instance_segmentations</span><span class="p">(</span><span class="n">binary_semantic_segmentations</span><span class="p">)</span>

        <span class="n">instance_segmentations_matched</span> <span class="o">=</span> <span class="n">matched_instances_across_timepoints</span><span class="p">(</span><span class="n">instance_segmentations</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method2DmeasComboBox</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;RANO_open2D&quot;</span><span class="p">,</span> <span class="s2">&quot;RANO_open3D&quot;</span><span class="p">]:</span>
            <span class="n">opened_segmentations</span> <span class="o">=</span> <span class="n">open_instance_segmentations</span><span class="p">(</span><span class="n">instance_segmentations_matched</span><span class="p">,</span>
                                                               <span class="n">opening_radius</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">radius_spinbox</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
            <span class="n">display_opened_segmentations</span><span class="p">(</span><span class="n">opened_segmentations</span><span class="p">,</span> <span class="n">segNodes</span><span class="p">)</span>
            <span class="n">instance_segmentations_matched</span> <span class="o">=</span> <span class="n">opened_segmentations</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">instance_segmentations_matched</span> <span class="o">=</span> <span class="n">instance_segmentations_matched</span>

        <span class="c1"># transform the instance segmentations to the original reference image space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resampledVolumeNodes</span> <span class="o">=</span> <span class="n">transform_to_and_resample_in_original_img_space</span><span class="p">(</span><span class="n">instance_segmentations_matched</span><span class="p">,</span>
                                                                                    <span class="n">segNodes</span><span class="p">)</span>

        <span class="c1"># hide the resampled labelmap volumes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">toggleShowInstanceSegPushButton</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onToggleShowInstanceSegButton</span><span class="p">()</span>

        <span class="n">lesion_stats</span> <span class="o">=</span> <span class="n">get_lesion_stats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resampledVolumeNodes</span><span class="p">)</span>

        <span class="c1"># remove the previous lines</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">[:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span> <span class="o">=</span> <span class="n">create_lineNodePairs</span><span class="p">(</span><span class="n">lesion_stats</span><span class="p">)</span>
        <span class="n">setLinePairViews</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">)</span>

        <span class="c1"># center views on first volume (reference volume)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onShowChannelButton</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="s1">&#39;timepoint1&#39;</span><span class="p">,</span> <span class="n">inputSelector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">inputSelector_channel1_t1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">onShowChannelButton</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="s1">&#39;timepoint2&#39;</span><span class="p">,</span> <span class="n">inputSelector</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">inputSelector_channel1_t2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_linepair_ui_list</span><span class="p">()</span>

        <span class="c1"># algorithms to set enhancing, measurable, target lesions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">decide_enhancing</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">decide_measurable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">decide_target</span><span class="p">()</span>

        <span class="c1"># calculate the results table</span>
        <span class="n">results_table_utils</span><span class="o">.</span><span class="n">ResultsTableMixin</span><span class="o">.</span><span class="n">calculate_results_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Measurements2DMixin.onToggleShowInstanceSegButton">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.onToggleShowInstanceSegButton">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">onToggleShowInstanceSegButton</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the &quot;Show/Hide Lesions&quot; button is pressed. It shows or hides the lesions in the</span>
<span class="sd">        slice views based on the resampled labelmap volumes. In the 3D views they are shown based on the resampled</span>
<span class="sd">        segmentation nodes (because the resampled labelmap volumes are not displayed smoothly in 3D, but voxelized).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># show or hide the label volumes via the slicecontrollerwidget</span>
        <span class="k">for</span> <span class="n">timepoint</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;timepoint1&quot;</span><span class="p">,</span> <span class="s2">&quot;timepoint2&quot;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span><span class="p">:</span>
                <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Red&quot;</span><span class="p">,</span> <span class="s2">&quot;Yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;Green&quot;</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint2&#39;</span><span class="p">:</span>
                <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Red_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Yellow_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Green_2&quot;</span><span class="p">]</span>
                <span class="n">tp</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;timepoint must be &#39;timepoint1&#39; or &#39;timepoint2&#39;&quot;</span><span class="p">)</span>

            <span class="n">checked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">toggleShowInstanceSegPushButton</span><span class="o">.</span><span class="n">checked</span>
            <span class="k">for</span> <span class="n">viewname</span> <span class="ow">in</span> <span class="n">viewnames</span><span class="p">:</span>
                <span class="n">compositeNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">sliceWidget</span><span class="p">(</span><span class="n">viewname</span><span class="p">)</span><span class="o">.</span><span class="n">sliceLogic</span><span class="p">()</span><span class="o">.</span><span class="n">GetSliceCompositeNode</span><span class="p">()</span>
                <span class="n">controller</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">sliceWidget</span><span class="p">(</span><span class="n">viewname</span><span class="p">)</span><span class="o">.</span><span class="n">sliceController</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">compositeNode</span><span class="o">.</span><span class="n">GetLabelVolumeID</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">GetID</span><span class="p">()</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampledVolumeNodes</span> <span class="k">if</span> <span class="n">node</span><span class="p">]:</span>
                    <span class="k">pass</span>
                    <span class="c1"># controller.setLabelMapHidden(True)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">compositeNode</span><span class="o">.</span><span class="n">SetLabelOpacity</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">checked</span><span class="p">:</span>
                        <span class="n">controller</span><span class="o">.</span><span class="n">setLabelMapHidden</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">controller</span><span class="o">.</span><span class="n">setLabelMapHidden</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># show or hide the 3D view</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampledSegNodes</span><span class="p">[</span><span class="n">tp</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resampledSegNodes</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">checked</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility2D</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility3D</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                    <span class="c1"># set opacity</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetOpacity</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetVisibility</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="Measurements2DMixin.onAddLinePairButton">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.onAddLinePairButton">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">onAddLinePairButton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the &quot;Add Lines t1&quot; or &quot;Add Lines t2&quot; button is pressed.</span>
<span class="sd">        It allows the user to add a new line pair for the selected timepoint by placing two lines in the slice views of</span>
<span class="sd">        the corresponding timepoint. The lines are added to the lineNodePairs list and displayed in the UI.</span>
<span class="sd">        Args:</span>
<span class="sd">            timepoint: the timepoint for which the line pair is added (e.g., &quot;timepoint1&quot; or &quot;timepoint2&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Add line pair button pressed&quot;</span><span class="p">)</span>
        <span class="n">lesion_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">add_line_lesidx_spinBox</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># check if the lesion index and timepoint already exist in the lineNodePairs</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">==</span> <span class="n">lesion_idx</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">timepoint</span><span class="p">:</span>
                <span class="c1"># show a message box</span>
                <span class="n">msgBox</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QMessageBox</span><span class="p">()</span>
                <span class="n">msgBox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Line pair for Lesion Index </span><span class="si">{</span><span class="n">lesion_idx</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2"> already exists&quot;</span><span class="p">)</span>
                <span class="n">msgBox</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span>
                <span class="k">return</span>

        <span class="n">newLineNodePair</span> <span class="o">=</span> <span class="n">LineNodePair</span><span class="p">(</span><span class="n">lesion_idx</span><span class="o">=</span><span class="n">lesion_idx</span><span class="p">,</span> <span class="n">timepoint</span><span class="o">=</span><span class="n">timepoint</span><span class="p">)</span>
        <span class="n">newLineNode1</span><span class="p">,</span> <span class="n">newLineNode2</span> <span class="o">=</span> <span class="n">newLineNodePair</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">setViews</span><span class="p">(</span><span class="n">newLineNodePair</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">)</span>

        <span class="c1"># go into placement mode for the new line</span>
        <span class="n">persistentPlaceMode</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># need to be in persistent mode to place the second line after first</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">markups</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">StartPlaceMode</span><span class="p">(</span><span class="n">persistentPlaceMode</span><span class="p">)</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">markups</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">SetActiveListID</span><span class="p">(</span><span class="n">newLineNode1</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">place_line2</span><span class="p">(</span><span class="n">lineNode1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">lineNode1</span><span class="o">.</span><span class="n">GetNumberOfControlPoints</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># go into placement mode for the new line</span>

                <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">markups</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">SetActiveListID</span><span class="p">(</span><span class="n">newLineNode2</span><span class="p">)</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">end_placement</span><span class="p">(</span><span class="n">lineNode2</span><span class="p">,</span> <span class="n">arg2</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">lineNode2</span><span class="o">.</span><span class="n">GetNumberOfControlPoints</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">markups</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">StartPlaceMode</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># exit placement mode</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">add_linePair</span><span class="p">(</span><span class="n">lineNode2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">lineNode2</span><span class="o">.</span><span class="n">GetNumberOfControlPoints</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">line_lenghts</span> <span class="o">=</span> <span class="n">newLineNodePair</span><span class="o">.</span><span class="n">get_line_lengths</span><span class="p">()</span>
                            <span class="n">newLineNodePair</span><span class="o">.</span><span class="n">measurable</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
                                <span class="p">[</span><span class="n">l</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">line_lenghts</span><span class="p">])</span> <span class="k">else</span> <span class="kc">False</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newLineNodePair</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">update_linepair_ui_list</span><span class="p">()</span>
                            <span class="c1"># set the views again after both lines have been defined so they can be removed from the views in which they are not orthogonal</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">setViews</span><span class="p">(</span><span class="n">newLineNodePair</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">)</span>

                            <span class="k">for</span> <span class="n">observedNode</span><span class="p">,</span> <span class="n">observer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="p">:</span>
                                <span class="n">observedNode</span><span class="o">.</span><span class="n">RemoveObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>

                    <span class="n">add_linePair</span><span class="p">(</span><span class="n">lineNode2</span><span class="p">)</span>

                <span class="c1"># add callback to end placement mode AFTER the second line is placed</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newLineNode2</span><span class="p">,</span> <span class="n">newLineNode2</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">newLineNode2</span><span class="o">.</span><span class="n">PointPositionDefinedEvent</span><span class="p">,</span> <span class="n">end_placement</span><span class="p">)])</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">onPointRemovedEvent</span><span class="p">(</span><span class="n">lineNode</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">applicationLogic</span><span class="p">()</span><span class="o">.</span><span class="n">GetInteractionNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetCurrentInteractionMode</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># schedule removal the line pair if the user cancels the placement of either line</span>
                <span class="c1"># can&#39;t remove the lines immediately because one of the lines is the observer caller</span>

                <span class="c1"># remove observers</span>
                <span class="k">for</span> <span class="n">observedNode</span><span class="p">,</span> <span class="n">observer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="p">:</span>
                    <span class="n">observedNode</span><span class="o">.</span><span class="n">RemoveObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>

                <span class="n">qt</span><span class="o">.</span><span class="n">QTimer</span><span class="o">.</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">newLineNode1</span><span class="p">))</span>
                <span class="n">qt</span><span class="o">.</span><span class="n">QTimer</span><span class="o">.</span><span class="n">singleShot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">newLineNode2</span><span class="p">))</span>

        <span class="c1"># add callback to place the second line when the first line is placed</span>
        <span class="c1"># first remove previous observers</span>
        <span class="k">for</span> <span class="n">observedNode</span><span class="p">,</span> <span class="n">observer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="p">:</span>
            <span class="n">observedNode</span><span class="o">.</span><span class="n">RemoveObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newLineNode1</span><span class="p">,</span> <span class="n">newLineNode1</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">newLineNode1</span><span class="o">.</span><span class="n">PointPositionDefinedEvent</span><span class="p">,</span> <span class="n">place_line2</span><span class="p">)])</span>
        <span class="c1">#self.observations2.append([newLineNode2, newLineNode2.AddObserver(newLineNode2.PointPositionDefinedEvent, add_linePair)])</span>

        <span class="c1"># add callback to remove the line pair if the user cancels the placement of either line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newLineNode1</span><span class="p">,</span> <span class="n">newLineNode1</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">newLineNode1</span><span class="o">.</span><span class="n">PointRemovedEvent</span><span class="p">,</span> <span class="n">onPointRemovedEvent</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observations2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">newLineNode2</span><span class="p">,</span> <span class="n">newLineNode2</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">newLineNode2</span><span class="o">.</span><span class="n">PointRemovedEvent</span><span class="p">,</span> <span class="n">onPointRemovedEvent</span><span class="p">)])</span></div>


<div class="viewcode-block" id="Measurements2DMixin.update_linepair_ui_list">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.update_linepair_ui_list">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update_linepair_ui_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method updates the UI list of line pairs by populating the table with the lesion index, timepoint, and</span>
<span class="sd">        whether the lesion is enhancing, measurable, and target. It also sets the background color of the rows such that</span>
<span class="sd">        rows of the same lesion index are grouped together for better readability.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">onCellClicked</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Called when a cell is clicked.&quot;&quot;&quot;</span>
            <span class="n">les_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">())</span>
            <span class="n">tp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>

            <span class="c1"># center timepoint&#39;s views on the clicked lesion</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">==</span> <span class="n">les_idx</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">tp</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">centerTimepointViewsOnCenterPoint</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">tp</span><span class="p">)</span>

        <span class="c1"># update the menu table</span>
        <span class="n">col_name_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Lesion Index&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Timepoint&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;Enhancing&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Measurable&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

        <span class="n">tableWidget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">tableWidget</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">setColumnCount</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">col_name_to_idx</span><span class="p">))</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">setHorizontalHeaderLabels</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">col_name_to_idx</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">setRowCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">clearContents</span><span class="p">()</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">verticalHeader</span><span class="p">()</span><span class="o">.</span><span class="n">setVisible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">tableWidget</span><span class="o">.</span><span class="n">cellClicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">onCellClicked</span><span class="p">)</span>
        <span class="n">prev_les_idx</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">color1</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QColor</span><span class="p">(</span><span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">,</span> <span class="mi">240</span><span class="p">)</span>
        <span class="n">color2</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QColor</span><span class="p">(</span><span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">255</span><span class="p">)</span>
        <span class="n">prev_color</span> <span class="o">=</span> <span class="n">color1</span>

        <span class="c1"># sort the lineNodePairs by lesion index and timepoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">custom_sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">lesion_idx</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">timepoint</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">pair_idx</span><span class="p">,</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">):</span>
            <span class="n">les_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span><span class="p">)</span>
            <span class="n">tp</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span>
            <span class="c1"># insert new row</span>
            <span class="n">row_count</span> <span class="o">=</span> <span class="n">tableWidget</span><span class="o">.</span><span class="n">rowCount</span>
            <span class="k">assert</span> <span class="n">row_count</span> <span class="o">==</span> <span class="n">pair_idx</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Row count: </span><span class="si">{</span><span class="n">row_count</span><span class="si">}</span><span class="s2">, pair_idx: </span><span class="si">{</span><span class="n">pair_idx</span><span class="si">}</span><span class="s2">, should be equal&quot;</span>
            <span class="n">tableWidget</span><span class="o">.</span><span class="n">insertRow</span><span class="p">(</span><span class="n">row_count</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">setRowColor</span><span class="p">(</span><span class="n">rowIdx</span><span class="p">,</span> <span class="n">color</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Set the background color of all cells in the row.&quot;&quot;&quot;</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">columnCount</span><span class="p">):</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">rowIdx</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">item</span><span class="p">:</span>
                        <span class="n">item</span><span class="o">.</span><span class="n">setBackground</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">QBrush</span><span class="p">(</span><span class="n">color</span><span class="p">))</span>
                        <span class="n">item</span><span class="o">.</span><span class="n">setTextAlignment</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">AlignCenter</span><span class="p">)</span>

            <span class="c1"># define the contents of the columns</span>
            <span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">col_name_to_idx</span><span class="p">[</span><span class="s2">&quot;Lesion Index&quot;</span><span class="p">],</span> <span class="n">qt</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">les_idx</span><span class="p">)))</span>
            <span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">col_name_to_idx</span><span class="p">[</span><span class="s2">&quot;Timepoint&quot;</span><span class="p">],</span> <span class="n">qt</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="n">tp</span><span class="p">))</span>

            <span class="c1"># place tick boxes in the &quot;Enhancing&quot;, &quot;Measurable&quot;, &quot;Target&quot; columns</span>
            <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Enhancing&quot;</span><span class="p">,</span> <span class="s2">&quot;Measurable&quot;</span><span class="p">,</span> <span class="s2">&quot;Target&quot;</span><span class="p">]:</span>
                <span class="n">checkbox</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QCheckBox</span><span class="p">()</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_target_selection</span><span class="p">(</span><span class="n">checkbox</span><span class="p">,</span> <span class="n">les_idx</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>

                    <span class="c1"># make sure selected target lesion is measurable</span>
                    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">==</span> <span class="n">les_idx</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">tp</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="ow">and</span> <span class="n">checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
                                <span class="n">msgBox</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QMessageBox</span><span class="p">()</span>
                                <span class="n">msgBox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Target lesion must be measurable&quot;</span><span class="p">)</span>
                                <span class="n">msgBox</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span>
                                <span class="n">checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                                <span class="k">return</span> <span class="kc">False</span>

                    <span class="c1"># count the number of enhancing and non-enhancing target lesions for current timepoint</span>
                    <span class="n">counter_enhancing</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">counter_non_enhancing</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">tp</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">enhancing</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
                            <span class="n">counter_enhancing</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="n">pair</span><span class="o">.</span><span class="n">enhancing</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span><span class="p">:</span>
                            <span class="n">counter_non_enhancing</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">err</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="n">counter_enhancing</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">counter_non_enhancing</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">counter_enhancing</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">counter_non_enhancing</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only 2 enhancing and 2 non-enhancing target lesions are allowed, but tried to add &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">counter_enhancing</span><span class="si">}</span><span class="s2"> enhancing and </span><span class="si">{</span><span class="n">counter_non_enhancing</span><span class="si">}</span><span class="s2"> non-enhancing target lesions &quot;</span>
                                   <span class="sa">f</span><span class="s2">&quot;for timepoint </span><span class="si">{</span><span class="n">tp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">counter_enhancing</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only 3 enhancing target lesions are allowed, but tried to add </span><span class="si">{</span><span class="n">counter_enhancing</span><span class="si">}</span><span class="s2"> &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;for timepoint </span><span class="si">{</span><span class="n">tp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">counter_non_enhancing</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">err</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Only 3 non-enhancing target lesions are allowed, but tried to add </span><span class="si">{</span><span class="n">counter_non_enhancing</span><span class="si">}</span><span class="s2"> &quot;</span>
                               <span class="sa">f</span><span class="s2">&quot;for timepoint </span><span class="si">{</span><span class="n">tp</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">err</span><span class="p">:</span>
                        <span class="n">msgBox</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QMessageBox</span><span class="p">()</span>
                        <span class="n">msgBox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                        <span class="n">msgBox</span><span class="o">.</span><span class="n">exec</span><span class="p">()</span>
                        <span class="n">checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
                        <span class="k">return</span> <span class="kc">False</span>

                    <span class="k">return</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">col_name</span> <span class="o">==</span> <span class="s2">&quot;Target&quot;</span><span class="p">:</span>
                    <span class="n">checkbox</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">is_valid_target_selection</span><span class="p">,</span> <span class="n">checkbox</span><span class="p">,</span> <span class="n">les_idx</span><span class="p">,</span> <span class="n">tp</span><span class="p">))</span>

                <span class="c1"># add callback to update the lineNodePair when the checkbox is clicked</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">onCheckboxToggled</span><span class="p">(</span><span class="n">checkbox</span><span class="p">,</span> <span class="n">les_idx</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Checkbox toggled to </span><span class="si">{</span><span class="n">checkbox</span><span class="o">.</span><span class="n">checked</span><span class="si">}</span><span class="s2"> for line pair of lesion index </span><span class="si">{</span><span class="n">les_idx</span><span class="si">}</span><span class="s2">, timepoint </span><span class="si">{</span><span class="n">tp</span><span class="si">}</span><span class="s2">, and column </span><span class="si">{</span><span class="n">col_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">==</span> <span class="n">les_idx</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">tp</span><span class="p">:</span>
                            <span class="nb">setattr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">col_name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">checkbox</span><span class="o">.</span><span class="n">checked</span><span class="p">)</span>

                    <span class="n">response_classification_utils</span><span class="o">.</span><span class="n">ResponseClassificationMixin</span><span class="o">.</span><span class="n">update_response_assessment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">)</span>

                <span class="n">checkbox</span><span class="o">.</span><span class="n">toggled</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">onCheckboxToggled</span><span class="p">,</span> <span class="n">checkbox</span><span class="p">,</span> <span class="n">les_idx</span><span class="p">,</span> <span class="n">tp</span><span class="p">,</span> <span class="n">col_name</span><span class="p">))</span>

                <span class="c1">#tableWidget.setCellWidget(row_count, col_name_to_idx[col_name], checkbox)</span>
                <span class="c1"># make sure the checkbox is centered# make sure the checkbox is centered</span>
                <span class="n">widget</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QWidget</span><span class="p">()</span>
                <span class="n">layout</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QHBoxLayout</span><span class="p">(</span><span class="n">widget</span><span class="p">)</span>
                <span class="n">layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="n">checkbox</span><span class="p">)</span>
                <span class="n">layout</span><span class="o">.</span><span class="n">setAlignment</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">Qt</span><span class="o">.</span><span class="n">AlignCenter</span><span class="p">)</span>
                <span class="n">layout</span><span class="o">.</span><span class="n">setContentsMargins</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">tableWidget</span><span class="o">.</span><span class="n">setCellWidget</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">col_name_to_idx</span><span class="p">[</span><span class="n">col_name</span><span class="p">],</span> <span class="n">widget</span><span class="p">)</span>

                <span class="n">checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="n">col_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>

            <span class="c1"># place push button in the &quot;Delete&quot; column</span>
            <span class="n">deleteButton</span> <span class="o">=</span> <span class="n">qt</span><span class="o">.</span><span class="n">QPushButton</span><span class="p">()</span>
            <span class="n">deleteButton</span><span class="o">.</span><span class="n">setIcon</span><span class="p">(</span><span class="n">qt</span><span class="o">.</span><span class="n">QIcon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">resourcePath</span><span class="p">(</span><span class="s1">&#39;Icons/trash.png&#39;</span><span class="p">)))</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">deleteLinePair</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Deleting line pair at index </span><span class="si">{</span><span class="n">index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update_linepair_ui_list</span><span class="p">()</span>

            <span class="n">deleteButton</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">deleteLinePair</span><span class="p">,</span> <span class="n">pair_idx</span><span class="p">))</span>

            <span class="n">tableWidget</span><span class="o">.</span><span class="n">setCellWidget</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">col_name_to_idx</span><span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">],</span> <span class="n">deleteButton</span><span class="p">)</span>
            <span class="c1"># make the row narrow</span>
            <span class="n">tableWidget</span><span class="o">.</span><span class="n">horizontalHeader</span><span class="p">()</span><span class="o">.</span><span class="n">resizeSection</span><span class="p">(</span><span class="n">col_name_to_idx</span><span class="p">[</span><span class="s2">&quot; &quot;</span><span class="p">],</span> <span class="mi">10</span><span class="p">)</span>

            <span class="n">other_color</span> <span class="o">=</span> <span class="n">color1</span> <span class="k">if</span> <span class="n">prev_color</span> <span class="o">==</span> <span class="n">color2</span> <span class="k">else</span> <span class="n">color2</span>
            <span class="n">selected_color</span> <span class="o">=</span> <span class="n">prev_color</span> <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">prev_les_idx</span> <span class="ow">or</span> <span class="n">les_idx</span> <span class="o">==</span> <span class="n">prev_les_idx</span><span class="p">)</span> <span class="k">else</span> <span class="n">other_color</span>
            <span class="n">prev_color</span> <span class="o">=</span> <span class="n">selected_color</span>
            <span class="n">prev_les_idx</span> <span class="o">=</span> <span class="n">les_idx</span>

            <span class="n">setRowColor</span><span class="p">(</span><span class="n">row_count</span><span class="p">,</span> <span class="n">selected_color</span><span class="p">)</span>

            <span class="c1"># make all rows narrow</span>
            <span class="n">row_height</span> <span class="o">=</span> <span class="mi">20</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">rowCount</span><span class="p">):</span>
                <span class="n">tableWidget</span><span class="o">.</span><span class="n">setRowHeight</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">row_height</span><span class="p">)</span>

                <span class="c1"># if the text font is too large, the actual row height will be larger than the set row height</span>
                <span class="n">row_height</span> <span class="o">=</span> <span class="n">tableWidget</span><span class="o">.</span><span class="n">rowHeight</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># make the columns fit the content</span>
            <span class="n">tableWidget</span><span class="o">.</span><span class="n">resizeColumnsToContents</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setFixedHeight</span><span class="p">((</span><span class="n">row_height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">rowCount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>

        <span class="n">response_classification_utils</span><span class="o">.</span><span class="n">ResponseClassificationMixin</span><span class="o">.</span><span class="n">update_response_assessment</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">)</span>
        <span class="n">response_classification_utils</span><span class="o">.</span><span class="n">ResponseClassificationMixin</span><span class="o">.</span><span class="n">update_overall_response_params</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="p">)</span>
        <span class="n">response_classification_utils</span><span class="o">.</span><span class="n">ResponseClassificationMixin</span><span class="o">.</span><span class="n">update_overall_response_status</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ui</span><span class="p">)</span></div>



<div class="viewcode-block" id="Measurements2DMixin.coords_ijk_to_world">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.coords_ijk_to_world">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">coords_ijk_to_world</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords_ijk</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the coordinates from IJK to world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_ijk</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="n">ijkToWorld</span> <span class="o">=</span> <span class="n">get_ijk_to_world_matrix</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="n">l1p1</span><span class="p">,</span> <span class="n">l1p2</span><span class="p">,</span> <span class="n">l2p1</span><span class="p">,</span> <span class="n">l2p2</span> <span class="o">=</span> <span class="n">coords_ijk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords_ijk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords_ijk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">coords_ijk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">controlPointsLine1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">transform_ijk_to_world_coord</span><span class="p">(</span><span class="n">l1p1</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="p">),</span>
                                       <span class="n">transform_ijk_to_world_coord</span><span class="p">(</span><span class="n">l1p2</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="p">)])</span>
        <span class="n">controlPointsLine2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">transform_ijk_to_world_coord</span><span class="p">(</span><span class="n">l2p1</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="p">),</span>
                                       <span class="n">transform_ijk_to_world_coord</span><span class="p">(</span><span class="n">l2p2</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="p">)])</span>

        <span class="n">coords_world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">controlPointsLine1</span><span class="p">,</span> <span class="n">controlPointsLine2</span><span class="p">])</span>  <span class="c1"># 2 lines, 2 points, 3 coordinates</span>

        <span class="k">return</span> <span class="n">coords_world</span></div>


<div class="viewcode-block" id="Measurements2DMixin.setViews">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.setViews">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">setViews</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the views for the line node pair such that the lines are only shown in the views corresponding to the</span>
<span class="sd">        timepoint and the line orientation (sagittal, coronal, axial) of the line pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span><span class="p">:</span>
            <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Red&quot;</span><span class="p">,</span> <span class="s2">&quot;Yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;Green&quot;</span><span class="p">]</span>
            <span class="n">viewname_3D</span> <span class="o">=</span> <span class="s2">&quot;view3d_1&quot;</span>
        <span class="k">elif</span> <span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint2&#39;</span><span class="p">:</span>
            <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Red_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Yellow_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Green_2&quot;</span><span class="p">]</span>
            <span class="n">viewname_3D</span> <span class="o">=</span> <span class="s2">&quot;view3d_2&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;timepoint must be &#39;timepoint1&#39; or &#39;timepoint2&#39; but is </span><span class="si">{</span><span class="n">timepoint</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># if the node is a line node, show the line only in the views in which the line lies</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LineNodePair</span><span class="p">):</span>
            <span class="c1"># get the control point positions</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">get_coords</span><span class="p">()</span>
            <span class="c1"># check that there are no nan values in the coords</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">find_closest_plane</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">viewnames</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">viewnames</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">viewnames</span> <span class="o">=</span> <span class="p">[</span><span class="n">viewnames</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="n">viewNodeIDs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">viewname</span> <span class="ow">in</span> <span class="n">viewnames</span><span class="p">:</span>
            <span class="n">viewNodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">sliceWidget</span><span class="p">(</span><span class="n">viewname</span><span class="p">)</span><span class="o">.</span><span class="n">sliceLogic</span><span class="p">()</span><span class="o">.</span><span class="n">GetSliceNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetID</span><span class="p">())</span>
        <span class="c1"># add the 3D view</span>
        <span class="c1"># loop over all 3D views to find the correct one</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">threeDViewCount</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">threeDWidget</span><span class="p">(</span>
                    <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">threeDView</span><span class="p">()</span><span class="o">.</span><span class="n">mrmlViewNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetSingletonTag</span><span class="p">()</span> <span class="o">==</span> <span class="n">viewname_3D</span><span class="p">:</span>
                <span class="n">threeDWidget_idx</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not find the 3D view with singleton tag </span><span class="si">{</span><span class="n">viewname_3D</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">viewNodeIDs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">layoutManager</span><span class="p">()</span><span class="o">.</span><span class="n">threeDWidget</span><span class="p">(</span>
            <span class="n">threeDWidget_idx</span><span class="p">)</span><span class="o">.</span><span class="n">threeDView</span><span class="p">()</span><span class="o">.</span><span class="n">mrmlViewNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetID</span><span class="p">())</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LineNodePair</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">lineNode</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="n">lineNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetViewNodeIDs</span><span class="p">(</span><span class="n">viewNodeIDs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetViewNodeIDs</span><span class="p">(</span><span class="n">viewNodeIDs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">node</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetViewNodeIDs</span><span class="p">(</span><span class="n">viewNodeIDs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Measurements2DMixin.centerTimepointViewsOnFirstMarkupPoint">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.centerTimepointViewsOnFirstMarkupPoint">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">centerTimepointViewsOnFirstMarkupPoint</span><span class="p">(</span><span class="n">lineNode</span><span class="p">,</span> <span class="n">tp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Center the slice views and cameras on the first markup point of the line node.</span>
<span class="sd">        Args:</span>
<span class="sd">            lineNode: the line node to center on</span>
<span class="sd">            tp: the timepoint to center on (e.g., &quot;timepoint1&quot; or &quot;timepoint2&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># center view group on the first markup point</span>
        <span class="c1"># Center slice views and cameras on this position</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">lineNode</span><span class="o">.</span><span class="n">GetNthControlPointPositionWorld</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">viewgroup_to_set</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">tp</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">sliceNode</span> <span class="ow">in</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNodesByClass</span><span class="p">(</span><span class="s1">&#39;vtkMRMLSliceNode&#39;</span><span class="p">):</span>
            <span class="n">viewgroup</span> <span class="o">=</span> <span class="n">sliceNode</span><span class="o">.</span><span class="n">GetViewGroup</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">viewgroup</span> <span class="o">==</span> <span class="n">viewgroup_to_set</span><span class="p">:</span>
                <span class="n">sliceNode</span><span class="o">.</span><span class="n">JumpSliceByCentering</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">viewNode</span> <span class="ow">in</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNodesByClass</span><span class="p">(</span><span class="s1">&#39;vtkMRMLViewNode&#39;</span><span class="p">):</span>
            <span class="n">view_group</span> <span class="o">=</span> <span class="n">viewNode</span><span class="o">.</span><span class="n">GetViewGroup</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">view_group</span> <span class="o">==</span> <span class="n">viewgroup_to_set</span><span class="p">:</span>
                <span class="n">camera</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">cameras</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">GetViewActiveCameraNode</span><span class="p">(</span><span class="n">viewNode</span><span class="p">)</span>
                <span class="n">camera</span><span class="o">.</span><span class="n">SetFocalPoint</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span></div>


<div class="viewcode-block" id="Measurements2DMixin.centerTimepointViewsOnCenterPoint">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.Measurements2DMixin.centerTimepointViewsOnCenterPoint">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">centerTimepointViewsOnCenterPoint</span><span class="p">(</span><span class="n">lineNodePair</span><span class="p">,</span> <span class="n">tp</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Center the slice views and cameras on the center point of the line node pair.</span>
<span class="sd">        Args:</span>
<span class="sd">            lineNodePair: the line node pair to center on</span>
<span class="sd">            tp: the timepoint to center on (e.g., &quot;timepoint1&quot; or &quot;timepoint2&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">lineNodePair</span><span class="o">.</span><span class="n">get_coords</span><span class="p">()</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">point_closest_to_two_lines</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">center</span>
        <span class="n">viewgroup_to_set</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">tp</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">sliceNode</span> <span class="ow">in</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNodesByClass</span><span class="p">(</span><span class="s1">&#39;vtkMRMLSliceNode&#39;</span><span class="p">):</span>
            <span class="n">viewgroup</span> <span class="o">=</span> <span class="n">sliceNode</span><span class="o">.</span><span class="n">GetViewGroup</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">viewgroup</span> <span class="o">==</span> <span class="n">viewgroup_to_set</span><span class="p">:</span>
                <span class="n">sliceNode</span><span class="o">.</span><span class="n">JumpSliceByCentering</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">viewNode</span> <span class="ow">in</span> <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">getNodesByClass</span><span class="p">(</span><span class="s1">&#39;vtkMRMLViewNode&#39;</span><span class="p">):</span>
            <span class="n">view_group</span> <span class="o">=</span> <span class="n">viewNode</span><span class="o">.</span><span class="n">GetViewGroup</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">view_group</span> <span class="o">==</span> <span class="n">viewgroup_to_set</span><span class="p">:</span>
                <span class="n">camera</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">cameras</span><span class="o">.</span><span class="n">logic</span><span class="p">()</span><span class="o">.</span><span class="n">GetViewActiveCameraNode</span><span class="p">(</span><span class="n">viewNode</span><span class="p">)</span>
                <span class="n">camera</span><span class="o">.</span><span class="n">SetFocalPoint</span><span class="p">(</span><span class="o">*</span><span class="n">position</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="LineNodePair">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LineNodePair</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class that represents a pair of line nodes for a lesion in a timepoint. The class inherits from list to allow</span>
<span class="sd">    easy access to the line nodes. The class also contains methods to create the line nodes, set and get their</span>
<span class="sd">    coordinates, and set the views for the line nodes. The class also contains methods to create a fiducial node for</span>
<span class="sd">    the text label of the line nodes and to handle events when the line nodes are modified.</span>
<span class="sd">    The class also contains methods to set the enhancing, measurable, and target properties of the line nodes.</span>

<span class="sd">    Args:</span>
<span class="sd">        lesion_idx: the index of the lesion</span>
<span class="sd">        timepoint: the timepoint for which the line nodes are created (e.g., &quot;timepoint1&quot; or &quot;timepoint2&quot;)</span>
<span class="sd">        enhancing: whether the lesion is enhancing or not (default: True)</span>
<span class="sd">        measurable: whether the lesion is measurable or not (default: True)</span>
<span class="sd">        target: whether the lesion is a target lesion or not (default: False)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lesion_idx</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">,</span> <span class="n">enhancing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">measurable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">lineNode1</span><span class="p">,</span> <span class="n">lineNode2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_twoLineNodes</span><span class="p">(</span><span class="n">lesion_idx</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([</span><span class="n">lineNode1</span><span class="p">,</span> <span class="n">lineNode2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">=</span> <span class="n">lesion_idx</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Lesion index&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">=</span> <span class="n">timepoint</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Timepoint for which the line node pair is created&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">enhancing</span> <span class="o">=</span> <span class="n">enhancing</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the lesion is enhancing or not&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">measurable</span> <span class="o">=</span> <span class="n">measurable</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the lesion is measurable or not&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the lesion is a target lesion or not&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fiducialNodeForText</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_fiducialNodeFor_text</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fiducial node for the text label of the line nodes&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span> <span class="o">=</span> <span class="p">[]</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of observers for the line nodes&quot;&quot;&quot;</span>

        <span class="c1"># add the observers for the lines that trigger when the line nodes are modified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lineNode1</span><span class="p">,</span> <span class="n">lineNode1</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">vtk</span><span class="o">.</span><span class="n">vtkCommand</span><span class="o">.</span><span class="n">ModifiedEvent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uponLineNodeModifiedEvent</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lineNode2</span><span class="p">,</span> <span class="n">lineNode2</span><span class="o">.</span><span class="n">AddObserver</span><span class="p">(</span><span class="n">vtk</span><span class="o">.</span><span class="n">vtkCommand</span><span class="o">.</span><span class="n">ModifiedEvent</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uponLineNodeModifiedEvent</span><span class="p">)])</span>

<div class="viewcode-block" id="LineNodePair.set_coords">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.set_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the coordinates of the line nodes to the given world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">lineNode</span><span class="p">,</span> <span class="n">coord</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>  <span class="c1"># note: looping over self returns the line nodes because self is a list of line nodes</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
            <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">updateMarkupsControlPointsFromArray</span><span class="p">(</span><span class="n">lineNode</span><span class="p">,</span> <span class="n">coord</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">uponLineNodeModifiedEvent</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="LineNodePair.get_coords">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.get_coords">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the coordinates of the line nodes in world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">lineNode</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="c1"># check if both control points exist</span>
            <span class="n">controlpoint1_exists</span> <span class="o">=</span> <span class="n">lineNode</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">controlpoint2_exists</span> <span class="o">=</span> <span class="n">lineNode</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">controlpoint1_exists</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">controlpoint2_exists</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c1"># leave the coords nan</span>

            <span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lineNode</span><span class="o">.</span><span class="n">GetNthControlPointPositionWorld</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">coords</span></div>


<div class="viewcode-block" id="LineNodePair.get_line_lengths">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.get_line_lengths">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_line_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the lengths of the lines in world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">len1</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span>
        <span class="n">len2</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">len1</span><span class="p">,</span> <span class="n">len2</span></div>


<div class="viewcode-block" id="LineNodePair.get_line_length_product">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.get_line_length_product">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_line_length_product</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the product of the lengths of the lines in world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">len1</span><span class="p">,</span> <span class="n">len2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_line_lengths</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">len1</span> <span class="o">*</span> <span class="n">len2</span></div>


<div class="viewcode-block" id="LineNodePair.create_twoLineNodes">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.create_twoLineNodes">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_twoLineNodes</span><span class="p">(</span><span class="n">les_idx</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create two line nodes for the line pair and set their properties.</span>
<span class="sd">        Args:</span>
<span class="sd">            les_idx: the index of the lesion</span>
<span class="sd">            timepoint: the timepoint for which the line nodes are created (e.g., &quot;timepoint1&quot; or &quot;timepoint2&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the line nodes</span>
        <span class="n">lineNode1Name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;l1_les</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">les_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">timepoint</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;timepoint&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;t&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">lineNode2Name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;l2_les</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">les_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">timepoint</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;timepoint&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;t&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># check if the line already exists</span>
        <span class="n">lineNode1</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">lineNode1Name</span><span class="p">)</span>
        <span class="n">lineNode2</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">lineNode2Name</span><span class="p">)</span>

        <span class="c1"># remove the line nodes if they already exist and create new ones</span>
        <span class="k">if</span> <span class="n">lineNode1</span><span class="p">:</span>
            <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">lineNode1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lineNode2</span><span class="p">:</span>
            <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">lineNode2</span><span class="p">)</span>

        <span class="n">lineNode1</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">AddNewNodeByClass</span><span class="p">(</span><span class="s2">&quot;vtkMRMLMarkupsLineNode&quot;</span><span class="p">,</span> <span class="n">lineNode1Name</span><span class="p">)</span>
        <span class="n">lineNode2</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">AddNewNodeByClass</span><span class="p">(</span><span class="s2">&quot;vtkMRMLMarkupsLineNode&quot;</span><span class="p">,</span> <span class="n">lineNode2Name</span><span class="p">)</span>

        <span class="c1"># make the line thicker</span>
        <span class="n">lineNode1</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetLineThickness</span><span class="p">(</span><span class="mf">0.35</span><span class="p">)</span>
        <span class="n">lineNode2</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetLineThickness</span><span class="p">(</span><span class="mf">0.35</span><span class="p">)</span>

        <span class="c1"># make the control points smaller</span>
        <span class="n">lineNode1</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetGlyphScale</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">lineNode2</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetGlyphScale</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># hide the text of the line nodes</span>
        <span class="n">lineNode1</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetPropertiesLabelVisibility</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">lineNode2</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetPropertiesLabelVisibility</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">lineNode1</span><span class="p">,</span> <span class="n">lineNode2</span></div>


<div class="viewcode-block" id="LineNodePair.create_fiducialNodeFor_text">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.create_fiducialNodeFor_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">create_fiducialNodeFor_text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a fiducial node for the text label of the line nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># create an extra fiducial point that is only used to annotate the linePair (hiding the ctrlPoint point itself)</span>
        <span class="n">fiducialNodeName</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;text_fiducial_les</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lesion_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;timepoint&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;t&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">fiducialNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">GetFirstNodeByName</span><span class="p">(</span><span class="n">fiducialNodeName</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fiducialNode</span><span class="p">:</span>
            <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="n">fiducialNode</span><span class="p">)</span>
        <span class="n">fiducialNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">AddNewNodeByClass</span><span class="p">(</span><span class="s2">&quot;vtkMRMLMarkupsFiducialNode&quot;</span><span class="p">,</span> <span class="n">fiducialNodeName</span><span class="p">)</span>

        <span class="c1"># hide the control point glyph</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetGlyphScale</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># used for relative size</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetGlyphSize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># used for absolute size</span>

        <span class="c1"># add a ctrlPoint point to the scene</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">AddControlPoint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># for now, set the text to empty</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">SetNthControlPointLabel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="c1"># make text size smaller</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetTextScale</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

        <span class="c1"># turn the text shadow off</span>
        <span class="n">fiducialNode</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetTextProperty</span><span class="p">()</span><span class="o">.</span><span class="n">ShadowOff</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fiducialNode</span></div>


<div class="viewcode-block" id="LineNodePair.set_color_depending_on_orthogonality">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.set_color_depending_on_orthogonality">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_color_depending_on_orthogonality</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">lineNode1</span><span class="p">,</span> <span class="n">lineNode2</span><span class="p">,</span> <span class="n">fiducialNodeForText</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the color of the lines depending on whether they are orthogonal or not.</span>
<span class="sd">        Args:</span>
<span class="sd">            n: the event name</span>
<span class="sd">            e: the event object</span>
<span class="sd">            lineNode1: the first line node</span>
<span class="sd">            lineNode2: the second line node</span>
<span class="sd">            fiducialNodeForText: the fiducial node for the text label of the line nodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the color of the lines depending on whether they are orthogonal</span>
        <span class="c1"># get the two lines</span>

        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Setting color depending on orthogonality&quot;</span><span class="p">)</span>
        <span class="n">line1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">lineNode1</span><span class="o">.</span><span class="n">GetNthControlPointPositionWorld</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lineNode1</span><span class="o">.</span><span class="n">GetNumberOfControlPoints</span><span class="p">())])</span>
        <span class="n">line2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[</span><span class="n">lineNode2</span><span class="o">.</span><span class="n">GetNthControlPointPositionWorld</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lineNode2</span><span class="o">.</span><span class="n">GetNumberOfControlPoints</span><span class="p">())])</span>

        <span class="c1"># get the direction vectors of the lines</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">line1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">line2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="n">dir1</span> <span class="o">=</span> <span class="n">line1</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">line1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dir2</span> <span class="o">=</span> <span class="n">line2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">line2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># normalize the direction vectors</span>
        <span class="n">dir1</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir1</span><span class="p">)</span>
        <span class="n">dir2</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">dir2</span><span class="p">)</span>

        <span class="c1"># calculate the dot product of the direction vectors</span>
        <span class="n">dot_product</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dir1</span><span class="p">,</span> <span class="n">dir2</span><span class="p">)</span>

        <span class="c1"># set the color of the lines depending on the dot product</span>
        <span class="n">tolerance_deg</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">min_deg</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">-</span> <span class="n">tolerance_deg</span>
        <span class="n">max_deg</span> <span class="o">=</span> <span class="mi">90</span> <span class="o">+</span> <span class="n">tolerance_deg</span>
        <span class="n">min_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">min_deg</span><span class="p">)</span>
        <span class="n">max_rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">max_deg</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">min_rad</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">dot_product</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">max_rad</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># green</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">color</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># red</span>

        <span class="n">lineNode1</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetSelectedColor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
        <span class="n">lineNode2</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetSelectedColor</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fiducialNodeForText</span><span class="p">:</span>
            <span class="n">fiducialNodeForText</span><span class="o">.</span><span class="n">GetDisplayNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetSelectedColor</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">v</span> <span class="o">/</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">color</span><span class="p">]))</span></div>


<div class="viewcode-block" id="LineNodePair.annotate_with_text">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.annotate_with_text">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">annotate_with_text</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Annotate the line nodes with the length of the lines in world coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set the location of the text to the middle of the line</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coords</span><span class="p">()</span>

        <span class="c1"># check if coords has nans</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># get the intersection point of the two lines</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="n">point_closest_to_two_lines</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>  <span class="c1"># get the middle point of the first line</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">center_point</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>

        <span class="c1"># set the location of the ctrlPoint point to the middle of the line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="o">.</span><span class="n">SetNthControlPointPosition</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">center_point</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center_point</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center_point</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">controlPoint_l1_0_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">controlPoint_l1_1_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">controlPoint_l2_0_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">controlPoint_l2_1_exists</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ControlPointExists</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">controlPoint_l1_0_exists</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">controlPoint_l1_1_exists</span><span class="p">:</span>
            <span class="n">line1LengthWorld</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">line1LengthWorld</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">controlPoint_l2_0_exists</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">controlPoint_l2_1_exists</span><span class="p">:</span>
            <span class="n">line2LengthWorld</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">line2LengthWorld</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">line1LengthWorld</span> <span class="ow">or</span> <span class="n">line2LengthWorld</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="o">.</span><span class="n">SetNthControlPointLabel</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
                                                             <span class="sa">f</span><span class="s2">&quot;Les </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lesion_idx</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">line1LengthWorld</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> x </span><span class="si">{</span><span class="n">line2LengthWorld</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LineNodePair.uponLineNodeModifiedEvent">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.uponLineNodeModifiedEvent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">uponLineNodeModifiedEvent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the line nodes are modified.</span>
<span class="sd">        It sets the color of the lines depending on whether they are orthogonal or not and updates the text label</span>
<span class="sd">        of the line nodes with the length of the lines in world coordinates.</span>
<span class="sd">        Args:</span>
<span class="sd">            n: the event name</span>
<span class="sd">            e: the event object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&quot;LineNode modified event&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_color_depending_on_orthogonality</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="p">)</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">calculate_results_table</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">lineNodePairs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">annotate_with_text</span><span class="p">()</span></div>


<div class="viewcode-block" id="LineNodePair.cleanup">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePair.cleanup">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleanup the line node pair by removing the observers and the fiducial node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># upon deletion of the object, remove the observers</span>
        <span class="k">for</span> <span class="n">observedNode</span><span class="p">,</span> <span class="n">observer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">observations</span><span class="p">:</span>
            <span class="n">observedNode</span><span class="o">.</span><span class="n">RemoveObserver</span><span class="p">(</span><span class="n">observer</span><span class="p">)</span>

        <span class="c1"># remove the fiducial node</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fiducialNodeForText</span><span class="p">)</span>

        <span class="c1"># remove the line nodes</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">mrmlScene</span><span class="o">.</span><span class="n">RemoveNode</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>



<div class="viewcode-block" id="LineNodePair.__repr__">
<a class="viewcode-back" href="../../autoapi/utils/measurements2D_utils/index.html#utils.measurements2D_utils.LineNodePair.__repr__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;LineNodePair(lesion_idx=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lesion_idx</span><span class="si">}</span><span class="s2">, timepoint=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">timepoint</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;lineNode1=</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, lineNode2=</span><span class="si">{</span><span class="bp">self</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="LineNodePairList">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LineNodePairList</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A list of LineNodePair objects. This class inherits from list to allow easy access to the line node pairs.</span>
<span class="sd">    The class also contains methods to add, remove, and modify the line node pairs. The class also contains methods</span>
<span class="sd">    to update the UI and the response assessment based on the line node pairs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="LineNodePairList.__delitem__">
<a class="viewcode-back" href="../../autoapi/utils/measurements2D_utils/index.html#utils.measurements2D_utils.LineNodePairList.__delitem__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that line nodes contained in the LineNodePairList are removed from the scene when removed from the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># Get all items that will be deleted</span>
            <span class="n">items</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
                <span class="n">item</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uponModified</span><span class="p">()</span></div>


<div class="viewcode-block" id="LineNodePairList.pop">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.pop">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes sure that line nodes contained in the LineNodePairList are removed from the scene when popped from the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">.</span><span class="n">cleanup</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uponModified</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="LineNodePairList.uponModified">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.uponModified">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">uponModified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the line node pairs are modified. It updates the UI and the response assessment</span>
<span class="sd">        based on the line node pairs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">calculate_results_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">update_response_assessment</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">ui</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">RANOWidget</span><span class="o">.</span><span class="n">update_linepair_ui_list</span><span class="p">()</span></div>


    <span class="c1"># make sure that the list is returned as a LineNodePairList when sorted</span>
<div class="viewcode-block" id="LineNodePairList.custom_sort">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.custom_sort">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">custom_sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the list of LineNodePair objects and return a new LineNodePairList object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_items</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">LineNodePairList</span><span class="p">(</span><span class="n">sorted_items</span><span class="p">)</span></div>


<div class="viewcode-block" id="LineNodePairList.decide_enhancing">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.decide_enhancing">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decide_enhancing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic to decide whether the lesion is enhancing or not. For now, all lesions are considered enhancing initially.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">pair</span><span class="o">.</span><span class="n">enhancing</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uponModified</span><span class="p">()</span></div>


<div class="viewcode-block" id="LineNodePairList.decide_measurable">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.decide_measurable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decide_measurable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Decide whether the lesion is measurable or not based on the orthogonal lines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># for now if both lines are more than 10 pixels long, the lesion is measurable</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uponModified</span><span class="p">()</span></div>


<div class="viewcode-block" id="LineNodePairList.decide_target">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.decide_target">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decide_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span><span class="s2">&quot;two_largest_enhancing&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Logic to decide whether the lesion is a target lesion or not. The strategy can be one of the following:</span>
<span class="sd">        - &quot;two_largest_enhancing&quot;: select the two largest enhancing lesions from the baseline</span>
<span class="sd">        - &quot;three_largest_enhancing&quot;: select the three largest enhancing lesions from the baseline</span>
<span class="sd">        - &quot;two_largest_enhancing_and_two_largest_non_enhancing&quot;: select the two largest enhancing lesions and the two</span>
<span class="sd">            largest non-enhancing lesions from the baseline</span>

<span class="sd">        Args:</span>
<span class="sd">            strategy: the strategy to use for selecting the target lesions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># set all target flags to False</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># sort the lesions by the product of the orthogonal lines</span>
        <span class="n">sorted_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">()</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">GetLineLengthWorld</span><span class="p">(),</span>
                                       <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">sorted_list_t1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_list</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s2">&quot;timepoint1&quot;</span><span class="p">]</span>
        <span class="n">sorted_list_t2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_list</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s2">&quot;timepoint2&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;two_largest_enhancing&quot;</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;three_largest_enhancing&quot;</span><span class="p">:</span>
            <span class="c1"># sort the lesions by the product of the orthogonal lines</span>

            <span class="n">counter_target_les</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_list_t1</span><span class="p">:</span>
                <span class="n">num_max</span> <span class="o">=</span> <span class="mi">2</span> <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;two_largest_enhancing&quot;</span> <span class="k">else</span> <span class="mi">3</span>
                <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="ow">and</span> <span class="n">counter_target_les</span> <span class="o">&lt;</span> <span class="n">num_max</span><span class="p">:</span>
                    <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">counter_target_les</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">elif</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;two_largest_enhancing_and_two_largest_non_enhancing&quot;</span><span class="p">:</span>
            <span class="n">counter_enhancing</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">counter_non_enhancing</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_list_t1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">enhancing</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">counter_enhancing</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">counter_enhancing</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">counter_non_enhancing</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">counter_non_enhancing</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># also set corresponding lesions in timepoint2 as targets</span>
        <span class="k">for</span> <span class="n">pair_t2</span> <span class="ow">in</span> <span class="n">sorted_list_t2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">sorted_list_t1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pair_t2</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="o">==</span> <span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span><span class="p">:</span>
                    <span class="n">pair_t2</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">uponModified</span><span class="p">()</span></div>


<div class="viewcode-block" id="LineNodePairList.get_number_of_targets">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_number_of_targets">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_targets</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of target lesions, but don&#39;t count the same lesion twice it is in the list twice (for both timepoints)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_les_idcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span><span class="p">]</span>
        <span class="n">num_target_lesions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_les_idcs</span><span class="p">))</span>  <span class="c1"># set to remove duplicates</span>
        <span class="k">return</span> <span class="n">num_target_lesions</span></div>


<div class="viewcode-block" id="LineNodePairList.get_number_of_new_target_lesions">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_number_of_new_target_lesions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_new_target_lesions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of new target lesions that were not target lesions at the first timepoint but appeared at the second</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_les_idcs_tp1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span><span class="p">]</span>
        <span class="n">target_les_idcs_tp2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint2&#39;</span><span class="p">]</span>
        <span class="n">num_new_target_lesions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_les_idcs_tp2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_les_idcs_tp1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num_new_target_lesions</span></div>


<div class="viewcode-block" id="LineNodePairList.get_number_of_disappeared_target_lesions">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_number_of_disappeared_target_lesions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_disappeared_target_lesions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of target lesions that were target lesions at the previous timepoints but are not target lesions</span>
<span class="sd">        because they disappeared</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target_les_idcs_tp1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span><span class="p">]</span>
        <span class="n">target_les_idcs_tp2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint2&#39;</span><span class="p">]</span>
        <span class="n">num_disappeared_target_lesions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">target_les_idcs_tp1</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">target_les_idcs_tp2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num_disappeared_target_lesions</span></div>


<div class="viewcode-block" id="LineNodePairList.get_number_of_new_measurable_lesions">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_number_of_new_measurable_lesions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_number_of_new_measurable_lesions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of new measurable lesions that were not measurable at the first timepoint but appeared at the second</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">measurable_les_idcs_tp1</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span>
                                   <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint1&#39;</span><span class="p">]</span>
        <span class="n">measurable_les_idcs_tp2</span> <span class="o">=</span> <span class="p">[</span><span class="n">pair</span><span class="o">.</span><span class="n">lesion_idx</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span> <span class="k">if</span>
                                   <span class="n">pair</span><span class="o">.</span><span class="n">measurable</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="s1">&#39;timepoint2&#39;</span><span class="p">]</span>
        <span class="n">num_new_measurable_lesions</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">measurable_les_idcs_tp2</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">measurable_les_idcs_tp1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">num_new_measurable_lesions</span></div>


<div class="viewcode-block" id="LineNodePairList.get_sum_of_bidimensional_products">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_sum_of_bidimensional_products">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sum_of_bidimensional_products</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">timepoint</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of line node pairs, this function returns the sum of bidimensional products of the orthogonal lines</span>
<span class="sd">        of all lesions at the given timepoint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_prod</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pair</span><span class="o">.</span><span class="n">target</span> <span class="ow">and</span> <span class="n">pair</span><span class="o">.</span><span class="n">timepoint</span> <span class="o">==</span> <span class="n">timepoint</span><span class="p">:</span>
                <span class="n">sum_prod</span> <span class="o">+=</span> <span class="n">pair</span><span class="o">.</span><span class="n">get_line_length_product</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sum_prod</span></div>


<div class="viewcode-block" id="LineNodePairList.get_rel_area_change">
<a class="viewcode-back" href="../../utils.measurements2D_utils.html#utils.measurements2D_utils.LineNodePairList.get_rel_area_change">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_rel_area_change</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a list of line node pairs, this function returns the relative change of the sum of bidimensional products of the</span>
<span class="sd">        orthogonal lines of all lesions at timepoint 2 relative to the sum of the bidimensional products of the orthogonal</span>
<span class="sd">        lines of all lesions at timepoint 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sum_prod_t1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sum_of_bidimensional_products</span><span class="p">(</span><span class="s2">&quot;timepoint1&quot;</span><span class="p">)</span>
        <span class="n">sum_prod_t2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sum_of_bidimensional_products</span><span class="p">(</span><span class="s2">&quot;timepoint2&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">sum_prod_t2</span> <span class="o">-</span> <span class="n">sum_prod_t1</span><span class="p">)</span> <span class="o">/</span> <span class="n">sum_prod_t1</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Aaron Kujawa.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>


<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>utils.rano_utils &mdash; RANO2.0-assist  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            RANO2.0-assist
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../README.html">RANO2.0-assist</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../autoapi/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RANO2.0-assist</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">utils.rano_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for utils.rano_utils</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span><span class="w"> </span><span class="nn">shutil</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">tqdm</span><span class="w"> </span><span class="kn">import</span> <span class="n">tqdm</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">vtk</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">slicer.util</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numba</span><span class="w"> </span><span class="kn">import</span> <span class="n">jit</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.ndimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">distance_transform_edt</span><span class="p">,</span> <span class="n">binary_dilation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">linear_sum_assignment</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">skimage</span><span class="w"> </span><span class="kn">import</span> <span class="n">segmentation</span><span class="p">,</span> <span class="n">measure</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">slicer</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">utils.config</span><span class="w"> </span><span class="kn">import</span> <span class="n">module_path</span><span class="p">,</span> <span class="n">debug</span><span class="p">,</span> <span class="n">dynunet_pipeline_path</span>


<div class="viewcode-block" id="run_segmentation">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.run_segmentation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_segmentation</span><span class="p">(</span><span class="n">inputVolume_list</span><span class="p">,</span>
                     <span class="n">do_affinereg</span><span class="p">,</span>
                     <span class="n">input_is_bet</span><span class="p">,</span>
                     <span class="n">task_dir</span><span class="p">,</span>
                     <span class="n">tmp_path_in</span><span class="p">,</span>
                     <span class="n">tmp_path_out</span><span class="p">,</span>
                     <span class="n">python_executable</span><span class="p">,</span>
                     <span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run the segmentation model using the provided input volumes and parameters.</span>

<span class="sd">    Args:</span>
<span class="sd">        inputVolume_list: list of volumes passed as input to the model</span>
<span class="sd">        do_affinereg: whether to register input volumes to template image</span>
<span class="sd">        input_is_bet: whether to register input volumes to template image</span>
<span class="sd">        task_dir: path to the task directory that contains the segmentation model</span>
<span class="sd">        tmp_path_in: path to the temporary input directory</span>
<span class="sd">        tmp_path_out: path to the temporary output directory</span>
<span class="sd">        python_executable: path to python executable (for example a virtual environment)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inputVolume_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No input volume specified for current timepoint.&quot;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputVolume_list</span><span class="p">)):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inputVolume_list</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Channel &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; input volume is invalid&quot;</span><span class="p">)</span>

    <span class="n">startTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>  <span class="c1"># to time the segmentation</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Processing started&#39;</span><span class="p">)</span>

    <span class="c1"># get the path to the external inference script</span>
    <span class="n">ext_inference_script_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dynunet_pipeline_path</span><span class="p">,</span> <span class="s2">&quot;src&quot;</span><span class="p">,</span> <span class="s2">&quot;inference.py&quot;</span><span class="p">)</span>

    <span class="c1"># empty the temporary input and output directories</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">):</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">tmp_path_out</span><span class="p">):</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">rmtree</span><span class="p">(</span><span class="n">tmp_path_out</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">tmp_path_out</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># create json file with the input and output paths as input for the inference script</span>
    <span class="n">inference_files_list</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s2">&quot;images&quot;</span><span class="p">:</span> <span class="p">{</span><span class="nb">str</span><span class="p">(</span><span class="n">ch</span><span class="p">):</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">,</span> <span class="s2">&quot;img_tmp_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nii.gz&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span>
                       <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inputVolume_list</span><span class="p">))</span>
                       <span class="p">},</span>
            <span class="s2">&quot;save_path&quot;</span><span class="p">:</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_path_out</span><span class="p">,</span> <span class="s2">&quot;output.nii.gz&quot;</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="n">inference_files_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">,</span> <span class="s2">&quot;inference_files.json&quot;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inference_files_path</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">inference_files_list</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

    <span class="c1"># save input nodes as nifti files in the temporary input directory</span>
    <span class="k">for</span> <span class="n">channel</span><span class="p">,</span> <span class="n">input_volume</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">inputVolume_list</span><span class="p">):</span>
        <span class="n">img_tmp_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_path_in</span><span class="p">,</span> <span class="s2">&quot;img_tmp_&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="si">{:04d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">channel</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;.nii.gz&quot;</span><span class="p">)</span>
        <span class="c1"># saveNode overwrites the storage node with the original filename, which is needed when the user wants to</span>
        <span class="c1"># rerun a section to get the report directory, hence, we overwrite the filename again</span>
        <span class="k">if</span> <span class="n">input_volume</span><span class="o">.</span><span class="n">GetStorageNode</span><span class="p">():</span>
            <span class="n">orig_fname</span> <span class="o">=</span> <span class="n">input_volume</span><span class="o">.</span><span class="n">GetStorageNode</span><span class="p">()</span><span class="o">.</span><span class="n">GetFileName</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">orig_fname</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="n">saveNode</span><span class="p">(</span><span class="n">input_volume</span><span class="p">,</span> <span class="n">img_tmp_path</span><span class="p">)</span>

        <span class="n">input_volume</span><span class="o">.</span><span class="n">GetStorageNode</span><span class="p">()</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">orig_fname</span><span class="p">)</span>

    <span class="c1"># provide paths (they must be absolute paths)</span>
    <span class="n">out_folder</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">realpath</span><span class="p">(</span><span class="n">tmp_path_out</span><span class="p">)</span>

    <span class="c1"># check if all paths exist</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">inference_files_path</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;Is not a file: </span><span class="si">{</span><span class="n">inference_files_path</span><span class="si">}</span><span class="s2"> ...&quot;</span>
    <span class="k">assert</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">out_folder</span><span class="p">)),</span> <span class="sa">f</span><span class="s2">&quot;Is not a folder: </span><span class="si">{</span><span class="n">out_folder</span><span class="si">}</span><span class="s2"> ...&quot;</span>

    <span class="k">if</span> <span class="n">python_executable</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">python_executable</span> <span class="o">=</span> <span class="s2">&quot;python&quot;</span>

    <span class="c1"># check if the system can find the external python</span>
    <span class="k">if</span> <span class="n">shutil</span><span class="o">.</span><span class="n">which</span><span class="p">(</span><span class="n">python_executable</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># warning</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Python executable </span><span class="si">{</span><span class="n">python_executable</span><span class="si">}</span><span class="s2"> not found ... </span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Falling back to PythonSlicer executable ...&quot;</span><span class="p">)</span>
        <span class="n">python_executable</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">executable</span>


    <span class="c1"># check if the external python is a virtual environment and if so, add the activate command to the beginning</span>
    <span class="n">activate_path</span> <span class="o">=</span> <span class="n">python_executable</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;activate&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">activate_path</span><span class="p">)):</span>
        <span class="n">python_executable</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">activate_path</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;; &quot;</span> <span class="o">+</span> <span class="n">python_executable</span>

    <span class="n">cmd</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">python_executable</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ext_inference_script_path</span><span class="si">}</span><span class="s2"> &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;-task_dir </span><span class="si">{</span><span class="n">task_dir</span><span class="si">}</span><span class="s2"> &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;-args_file config/infer_args.json &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;-inference_files_path </span><span class="si">{</span><span class="n">inference_files_path</span><span class="si">}</span><span class="s2"> &quot;</span>
           <span class="sa">f</span><span class="s2">&quot;-out_dir </span><span class="si">{</span><span class="n">out_folder</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">do_affinereg</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; -reg &quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; -no-reg &quot;</span>

    <span class="k">if</span> <span class="n">input_is_bet</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; -input_is_bet &quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cmd</span> <span class="o">+=</span> <span class="s2">&quot; -no-input_is_bet &quot;</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running command in run_command module: &quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

    <span class="c1"># run scripted CLI</span>
    <span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;command&quot;</span><span class="p">:</span> <span class="n">cmd</span><span class="p">}</span>
    <span class="n">cliNode</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">slicer</span><span class="o">.</span><span class="n">modules</span><span class="o">.</span><span class="n">run_command</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">)</span>

    <span class="n">stopTime</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Python script completed in </span><span class="si">{</span><span class="n">stopTime</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startTime</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> seconds&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cliNode</span></div>




<div class="viewcode-block" id="keep_contained_lines">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.keep_contained_lines">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">keep_contained_lines</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sample_distance</span><span class="o">=</span><span class="mf">0.2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a set of boundary coordinates, this method returns the lines that are fully contained within the mask.</span>

<span class="sd">    Args:</span>
<span class="sd">        boundary_coords: numpy array of shape (nb_boundary_pixels, 2)</span>
<span class="sd">        mask: binary numpy array of shape (width, height)</span>
<span class="sd">        sample_distance: the distance between samples on the line to check if the line is contained</span>

<span class="sd">    Returns:</span>
<span class="sd">        contained_lines: a list of lines, where each line is a list of two points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nb_coords</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">)</span>
    <span class="n">contained_lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># loop over all pairs of boundary pixels</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb_coords</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb_coords</span><span class="p">):</span>

            <span class="c1"># get the samples on the line between the two boundary pixels</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span>
                               <span class="p">(</span><span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="n">sample_distance</span><span class="p">)</span>
            <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>
            <span class="n">y_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">num</span><span class="o">=</span><span class="n">num_samples</span><span class="p">)</span>

            <span class="c1"># check if all samples are within the mask</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">y_vals</span><span class="p">):</span>
                <span class="n">x_mask</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="n">y_mask</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">mask</span><span class="p">[</span><span class="n">x_mask</span><span class="p">,</span> <span class="n">y_mask</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># if the loop completes without breaking</span>
                <span class="c1"># the line is fully contained within the mask</span>
                <span class="n">contained_lines</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">boundary_coords</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">boundary_coords</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">contained_lines</span></div>



<div class="viewcode-block" id="get_all_contained_lines">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.get_all_contained_lines">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_all_contained_lines</span><span class="p">(</span><span class="n">plane</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a plane, this function returns all the lines from one boundary pixel to another that are fully contained</span>
<span class="sd">    within the foreground.</span>

<span class="sd">    Args:</span>
<span class="sd">        plane: a 2D numpy array where background is 0 and foreground is &gt; 0</span>

<span class="sd">    Returns:</span>
<span class="sd">        contained_lines: a list of lines, where each line is a list of two points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">plane</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="c1"># empty planes have no lines</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>

    <span class="c1"># get the boundary of the mask</span>
    <span class="n">mask_boundary</span> <span class="o">=</span> <span class="n">segmentation</span><span class="o">.</span><span class="n">find_boundaries</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># pixels at the image boundary should also be considered as boundary pixels if they are part of the mask foreground</span>
    <span class="n">mask_boundary</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">mask_boundary</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
    <span class="n">mask_boundary</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">mask_boundary</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span><span class="p">[:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># get the coordinates of the boundary</span>
    <span class="n">boundary_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">(</span><span class="n">mask_boundary</span><span class="p">)</span>  <span class="c1"># shape: (nb_boundary_pixels, 2)</span>

    <span class="c1"># get the lines that are fully contained within the mask</span>
    <span class="n">contained_lines</span> <span class="o">=</span> <span class="n">keep_contained_lines</span><span class="p">(</span><span class="n">boundary_coords</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">sample_distance</span><span class="o">=</span><span class="mf">0.2</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">debug</span> <span class="k">else</span> <span class="mi">3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">contained_lines</span></div>


<div class="viewcode-block" id="get_max_orthogonal_line_product_coords_plane">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.get_max_orthogonal_line_product_coords_plane">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_max_orthogonal_line_product_coords_plane</span><span class="p">(</span><span class="n">line_coords</span><span class="p">,</span> <span class="n">degree_tol</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Given a set of lines, this function returns the two lines that are orthogonal to each other and have the largest</span>
<span class="sd">    product of their lengths. The third condition is that the lines must intersect. The function</span>
<span class="sd">    loops over all lines and checks if the angle between the lines is orthogonal (within the given tolerance).</span>
<span class="sd">    It is assumed that all lines lie in a plane (one of the acquisition planes). This plane can have any orientation in</span>
<span class="sd">    world space.</span>

<span class="sd">    Args:</span>
<span class="sd">        line_coords: numpy array of shape (nb_lines, 2, 3) (lines x 2 points x 3 coordinates)</span>
<span class="sd">        degree_tol: the tolerance in degrees for the orthogonality of the lines</span>

<span class="sd">    Returns:</span>
<span class="sd">        ortho_line_max_prod_coords: a list of two lines, where each line is a list of two points and the product</span>
<span class="sd">        of their lengths is maximal</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
        <span class="c1"># pick only 10 lines</span>
        <span class="n">line_coords</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span>

    <span class="n">num_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line_coords</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">num_lines</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">radians_tol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">degree_tol</span><span class="p">)</span>

    <span class="c1"># precalculate the line lengths and angles with respect to one of the lines in the plane</span>
    <span class="n">vecs_world</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">line_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">ref_line</span> <span class="o">=</span> <span class="n">vecs_world</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># reference line</span>

    <span class="k">for</span> <span class="n">vec_idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vecs_world</span><span class="p">)):</span>
        <span class="n">ref_line2</span> <span class="o">=</span> <span class="n">vecs_world</span><span class="p">[</span><span class="n">vec_idx</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># reference line 2 to calculate the normal</span>
        <span class="n">crossprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ref_line</span><span class="p">,</span> <span class="n">ref_line2</span><span class="p">)</span>
        <span class="n">normcrossprod</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">crossprod</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normcrossprod</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>  <span class="c1"># check if the two lines are not parallel. set threshold to avoid numerical issues</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#print(&quot;No orthogonal vectors found.&quot;)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># get the plane normal</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">crossprod</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">crossprod</span><span class="p">)</span>

    <span class="c1"># get the signed angle between the reference line and the other lines by projecting on the normal</span>
    <span class="c1"># sorting the angles is done to assess only roughly orthogonal lines and avoid O(n^2) complexity</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ref_line</span><span class="p">,</span> <span class="n">vecs_world</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">ref_line</span><span class="p">,</span> <span class="n">vecs_world</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>

    <span class="c1"># calculate the line lengths</span>
    <span class="n">line_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">vecs_world</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># sort angles, line_coords, line_lengths by angle</span>
    <span class="c1"># this is necessary to make the search for orthogonal lines more efficient</span>
    <span class="n">angles_sorted_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>
    <span class="n">angles</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">angles_sorted_idx</span><span class="p">]</span>
    <span class="n">line_coords</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">angles_sorted_idx</span><span class="p">]</span>
    <span class="n">line_lengths</span> <span class="o">=</span> <span class="n">line_lengths</span><span class="p">[</span><span class="n">angles_sorted_idx</span><span class="p">]</span>

    <span class="c1"># keep track of current maximum product of line lengths and corresponding line indices</span>
    <span class="n">ortho_line_products_max</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">max_l1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">max_l2</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># to check if the lines are in the same plane, we later project the lines onto a 2D plane</span>
    <span class="c1"># we need to define 2 basis vectors and a coordinate center to describe coordinates in the plane in 2D</span>
    <span class="c1"># pick an arbitrary vector that is orthogonal to the normal</span>
    <span class="n">ax1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># largest component of the normal</span>
    <span class="n">ax2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span><span class="p">))[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="c1"># second largest component of the normal</span>

    <span class="n">basis1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">basis1</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span> <span class="o">=</span> <span class="n">normal</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span>
    <span class="n">basis1</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">normal</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span>

    <span class="n">basis1</span> <span class="o">=</span> <span class="n">basis1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">basis1</span><span class="p">)</span>
    <span class="n">basis2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">basis1</span><span class="p">)</span>
    <span class="n">basis2</span> <span class="o">=</span> <span class="n">basis2</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">basis2</span><span class="p">)</span>
    <span class="c1"># the center can be the first point of the first line</span>
    <span class="n">center2D</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># start index for the search of orthogonal lines (initially 0) to avoid checking all angles</span>
    <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_lines</span><span class="p">):</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">angles</span><span class="p">[</span><span class="n">l1</span><span class="p">]</span>

        <span class="c1"># condition 1: the angle must be orthogonal (within tolerance radians_tol)</span>
        <span class="c1"># exact orthogonal angle</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">angle</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># range of acceptable directions</span>
        <span class="n">r_min</span> <span class="o">=</span> <span class="n">o</span> <span class="o">-</span> <span class="n">radians_tol</span> <span class="o">-</span> <span class="mf">1e-7</span>  <span class="c1"># subtract a small value to avoid numerical issues</span>
        <span class="n">r_max</span> <span class="o">=</span> <span class="n">o</span> <span class="o">+</span> <span class="n">radians_tol</span> <span class="o">+</span> <span class="mf">1e-7</span>

        <span class="c1"># to avoid checking all angles, we can update the start index to the first angle that is within the orthogonal</span>
        <span class="c1"># range</span>
        <span class="c1"># update the start idx to the first angle that is &gt;= r_min</span>
        <span class="k">while</span> <span class="n">angles</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">r_min</span> <span class="ow">and</span> <span class="n">start_idx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="n">num_lines</span> <span class="ow">and</span> <span class="n">angles</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">r_min</span><span class="p">:</span>
            <span class="n">start_idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">==</span> <span class="n">num_lines</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># loop over all angles from the start index (break when the angle becomes too large for the orthogonal range)</span>
        <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">num_lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">angles</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">r_max</span><span class="p">:</span>  <span class="c1"># this angle and following angles (larger, because of sorting) are too large</span>
                <span class="k">break</span>

            <span class="c1"># condition 2: vector length product must be larger than the current maximum</span>
            <span class="n">line_length_product</span> <span class="o">=</span> <span class="n">line_lengths</span><span class="p">[</span><span class="n">l1</span><span class="p">]</span> <span class="o">*</span> <span class="n">line_lengths</span><span class="p">[</span><span class="n">l2</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">line_length_product</span> <span class="o">&gt;</span> <span class="n">ortho_line_products_max</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># condition 3: make sure that the two lines are intersecting in the plane</span>
            <span class="c1"># get the 2x2 points of the two lines in terms of the basis vectors defined above</span>
            <span class="n">l1p1</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">l1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">l1p2</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">l1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">l2p1</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">l2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">l2p2</span> <span class="o">=</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">l2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># project the points onto the 2D plane</span>
            <span class="n">l1p1</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1p1</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1p1</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis2</span><span class="p">)]</span>
            <span class="n">l1p2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1p2</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l1p2</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis2</span><span class="p">)]</span>
            <span class="n">l2p1</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l2p1</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l2p1</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis2</span><span class="p">)]</span>
            <span class="n">l2p2</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l2p2</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">l2p2</span> <span class="o">-</span> <span class="n">center2D</span><span class="p">,</span> <span class="n">basis2</span><span class="p">)]</span>

            <span class="c1"># this solution of checking if the lines intersect is from https://stackoverflow.com/a/9997374</span>
            <span class="c1"># it doesn&#39;t work for parallel lines, but we already checked that the lines are orthogonal</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">ccw</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">):</span>
                <span class="c1"># Check if the points p1, p2, p3 are in counter-clockwise order</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">p3</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">p3</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Return true if line segments AB and CD intersect</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">intersect</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">ccw</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ccw</span><span class="p">(</span><span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ccw</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ccw</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">intersect</span><span class="p">(</span><span class="n">l1p1</span><span class="p">,</span> <span class="n">l1p2</span><span class="p">,</span> <span class="n">l2p1</span><span class="p">,</span> <span class="n">l2p2</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># all conditions are met, so we can update the maximum product</span>
            <span class="n">ortho_line_products_max</span> <span class="o">=</span> <span class="n">line_length_product</span>
            <span class="n">max_l1</span> <span class="o">=</span> <span class="n">l1</span>
            <span class="n">max_l2</span> <span class="o">=</span> <span class="n">l2</span>

    <span class="k">if</span> <span class="n">max_l1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">max_l2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No orthogonal lines found&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># get the coordinates of the two lines with the maximum product</span>
    <span class="n">ortho_line_max_prod_coords</span> <span class="o">=</span> <span class="p">[</span><span class="n">line_coords</span><span class="p">[</span><span class="n">max_l1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:],</span> <span class="n">line_coords</span><span class="p">[</span><span class="n">max_l2</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]]</span>

    <span class="k">return</span> <span class="n">ortho_line_max_prod_coords</span></div>



<div class="viewcode-block" id="get_instance_segmentation_by_connected_component_analysis">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.get_instance_segmentation_by_connected_component_analysis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_instance_segmentation_by_connected_component_analysis</span><span class="p">(</span><span class="n">bin_seg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a binary segmentation into a segmentation where each connected component gets a different label &gt; 0.</span>

<span class="sd">    Args:</span>
<span class="sd">        bin_seg: Binary segmentation with shape W, H, D and labels 0 and 1</span>

<span class="sd">    Returns:</span>
<span class="sd">        instance_seg: Segmentation with shape W, H, D and labels 0, ..., num_ccs (number of connected components)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># get connected components (each CC will get a different label)</span>
    <span class="n">instance_seg</span><span class="p">,</span> <span class="n">num_ccs</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">bin_seg</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">return_num</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">instance_seg</span></div>




<div class="viewcode-block" id="match_instance_segmentations_by_IoU">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.match_instance_segmentations_by_IoU">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">match_instance_segmentations_by_IoU</span><span class="p">(</span><span class="n">instance_segs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of instance segmentations, this function relabels the segmentations so that the labels match</span>
<span class="sd">    between timepoints. It does so by finding the optimal matching of labels based on the IoU (Intersection over</span>
<span class="sd">    Union) of the instances.</span>

<span class="sd">    Args:</span>
<span class="sd">        instance_segs: list of instance segmentations, where each segmentation is a 3D numpy array with shape (W, H, D) and</span>
<span class="sd">        labels 0, ..., num_instances (number of instances)</span>
<span class="sd">    Returns:</span>
<span class="sd">        matched_instance_segs: list of instance segmentations with matching labels between timepoints</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_matched_labels</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">seg2</span><span class="p">):</span>
        <span class="c1"># calculate the overlap between each pair of connected components</span>
        <span class="n">ccs_t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg1</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ccs_t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg2</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>

        <span class="n">iou</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">ccs_t1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ccs_t2</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cc1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ccs_t1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cc2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ccs_t2</span><span class="p">):</span>
                <span class="n">overlap</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">seg1</span> <span class="o">==</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">seg2</span> <span class="o">==</span> <span class="n">cc2</span><span class="p">))</span>
                <span class="n">iou</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">overlap</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">seg1</span> <span class="o">==</span> <span class="n">cc1</span><span class="p">,</span> <span class="n">seg2</span> <span class="o">==</span> <span class="n">cc2</span><span class="p">))</span>

        <span class="c1"># find optimal matching based on minimizing average iou</span>
        <span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span> <span class="o">=</span> <span class="n">linear_sum_assignment</span><span class="p">(</span><span class="o">-</span><span class="n">iou</span><span class="p">)</span>

        <span class="n">labels_t1</span> <span class="o">=</span> <span class="n">ccs_t1</span><span class="p">[</span><span class="n">row_ind</span><span class="p">]</span>
        <span class="n">labels_t2</span> <span class="o">=</span> <span class="n">ccs_t2</span><span class="p">[</span><span class="n">col_ind</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">labels_t1</span><span class="p">,</span> <span class="n">labels_t2</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">relabel_seg</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">,</span> <span class="n">matched_labs</span><span class="p">,</span> <span class="n">seg</span><span class="p">):</span>
        <span class="c1"># if some labels in seg are not in matched_labs, we need to assign them to new (arbitrary) labels</span>
        <span class="n">orig_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="n">unmatched_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">orig_labels</span><span class="p">,</span> <span class="n">matched_labs</span><span class="p">)</span>
        <span class="c1"># assign new labels are the next available label (not in ref_labs)</span>
        <span class="n">unmatched_labels_new</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">orig_labels</span><span class="p">)))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">ref_labs</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">unmatched_labels</span><span class="p">)])</span>

        <span class="n">seg_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">src</span><span class="p">,</span> <span class="n">dest</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">matched_labs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">unmatched_labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                             <span class="n">ref_labs</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">+</span> <span class="n">unmatched_labels_new</span><span class="o">.</span><span class="n">tolist</span><span class="p">()):</span>
            <span class="n">seg_out</span><span class="p">[</span><span class="n">seg</span> <span class="o">==</span> <span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="n">dest</span>

        <span class="k">return</span> <span class="n">seg_out</span>

    <span class="n">num_segs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">instance_segs</span><span class="p">)</span>

    <span class="c1"># change labels of each segmentation to match to the previous timepoint</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_segs</span><span class="p">):</span>
        <span class="n">seg1</span> <span class="o">=</span> <span class="n">instance_segs</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">seg2</span> <span class="o">=</span> <span class="n">instance_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="n">labels_t1</span><span class="p">,</span> <span class="n">labels_t2</span> <span class="o">=</span> <span class="n">get_matched_labels</span><span class="p">(</span><span class="n">seg1</span><span class="p">,</span> <span class="n">seg2</span><span class="p">)</span>
        <span class="c1"># update the labels in seg2</span>
        <span class="n">instance_segs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">relabel_seg</span><span class="p">(</span><span class="n">labels_t1</span><span class="p">,</span> <span class="n">labels_t2</span><span class="p">,</span> <span class="n">seg2</span><span class="p">)</span>

    <span class="n">matched_instance_segs</span> <span class="o">=</span> <span class="n">instance_segs</span>

    <span class="k">return</span> <span class="n">matched_instance_segs</span></div>



<div class="viewcode-block" id="get_max_orthogonal_line_product_coords">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.get_max_orthogonal_line_product_coords">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_max_orthogonal_line_product_coords</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">valid_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">center_tol</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
                                           <span class="n">opening_radius</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ijkToWorld</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a segmentation, this function returns the two lines that are orthogonal to each other and have the largest</span>
<span class="sd">    product of their lengths. It does so by looping over views (axial, coronal, sagittal) and planes and finding the</span>
<span class="sd">    two lines with the largest product of their lengths that are orthogonal to each other.</span>

<span class="sd">    Args:</span>
<span class="sd">        seg: a 3D numpy array where background is 0 and foreground is &gt; 0. The array defines the IJK space.</span>
<span class="sd">        valid_axes: the IJK orientations to consider for finding the orthogonal lines</span>
<span class="sd">        center: IJK coordinates of a point that the plane must be close to</span>
<span class="sd">        center_tol: IJK tolerance for the distance between the plane and the center point</span>
<span class="sd">        opening_radius: the radius of the circle opening operation to apply to the slice segmentation before finding</span>
<span class="sd">        the orthogonal lines</span>
<span class="sd">        ijkToWorld: the transformation matrix to convert from voxel coordinates to world coordinates</span>

<span class="sd">    Returns:</span>
<span class="sd">        max_ortho_line_coords: a list of two lines, where each line is a list of two points and the product of their</span>
<span class="sd">        lengths is maximal. The coordinates are in world space.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># loop over all planes</span>
    <span class="n">max_ortho_line_coords</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">max_line_length_product</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">view</span> <span class="ow">in</span> <span class="n">valid_axes</span><span class="p">:</span>  <span class="c1"># loop over all views</span>
        <span class="n">slices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">seg</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">view</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>  <span class="c1"># loop over all planes</span>
            <span class="c1"># get distance of the slice to the center point</span>
            <span class="k">if</span> <span class="n">center</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="n">view</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="n">center_tol</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># skip the slice if it is too far from the center point</span>

            <span class="c1"># get the plane</span>
            <span class="n">plane</span> <span class="o">=</span> <span class="n">seg</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">view</span><span class="p">)</span>

            <span class="c1"># check if the plane has any object</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># apply circle opening operation</span>
            <span class="k">if</span> <span class="n">opening_radius</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plane</span> <span class="o">=</span> <span class="n">circle_opening</span><span class="p">(</span><span class="n">plane</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">opening_radius</span><span class="p">)</span>

            <span class="c1"># check if the plane has any object after circle opening</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># get all contained lines</span>
            <span class="n">all_line_coords</span> <span class="o">=</span> <span class="n">get_all_contained_lines</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_line_coords</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">all_line_coords_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_line_coords</span><span class="p">)</span>  <span class="c1"># lines x 2 points x 2 coordinates</span>
            <span class="n">all_line_coords_np_3d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">all_line_coords_np</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

            <span class="c1"># convert the coordinates to world space</span>
            <span class="c1"># swap z and x from numpy to slicer</span>
            <span class="n">all_line_coords_np_3d_swapped</span> <span class="o">=</span> <span class="n">all_line_coords_np_3d</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="c1"># append 1 to the coordinates (homogeneous coordinates)</span>
            <span class="n">all_line_coords_np_3d_homo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">all_line_coords_np_3d_swapped</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
            <span class="c1"># matrix multiplication with einsum</span>
            <span class="n">all_line_coords_np_3d_world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ab,cdb-&gt;cda&#39;</span><span class="p">,</span>
                                                    <span class="n">slicer</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">arrayFromVTKMatrix</span><span class="p">(</span><span class="n">ijkToWorld</span><span class="p">),</span>
                                                    <span class="n">all_line_coords_np_3d_homo</span><span class="p">)[:,</span> <span class="p">:,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span>


            <span class="n">ortho_line_coords</span> <span class="o">=</span> <span class="n">get_max_orthogonal_line_product_coords_plane</span><span class="p">(</span><span class="n">all_line_coords_np_3d_world</span><span class="p">,</span>
                                                                             <span class="n">degree_tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">ortho_line_coords</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># calculate line length product</span>
            <span class="n">line_length1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ortho_line_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ortho_line_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">line_length2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">ortho_line_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ortho_line_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
            <span class="n">line_length_product</span> <span class="o">=</span> <span class="n">line_length1</span> <span class="o">*</span> <span class="n">line_length2</span>

            <span class="k">if</span> <span class="n">line_length_product</span> <span class="o">&gt;</span> <span class="n">max_line_length_product</span><span class="p">:</span>
                <span class="n">max_line_length_product</span> <span class="o">=</span> <span class="n">line_length_product</span>

                <span class="n">max_ortho_line_coords</span> <span class="o">=</span> <span class="n">ortho_line_coords</span>

                <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
                    <span class="k">break</span>

    <span class="n">max_ortho_line_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">max_ortho_line_coords</span><span class="p">)</span>

    <span class="c1"># print(&quot;Max product:&quot;, max_line_length_product)</span>
    <span class="c1"># print(&quot;Max product coords:&quot;, max_ortho_line_coords)</span>

    <span class="k">return</span> <span class="n">max_ortho_line_coords</span></div>




<div class="viewcode-block" id="circle_opening">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.circle_opening">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">circle_opening</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a segmentation, this function performs a circle opening operation on the specified labels.</span>
<span class="sd">    The opening operation is performed in 3 steps:</span>
<span class="sd">    1. A mask is created as the union of the specified labels</span>
<span class="sd">    2. The distance map of the mask is calculated and used to threshold the mask such that only the pixels that are</span>
<span class="sd">    at least radius away from the boundary of the mask are kept. This mask corresponds to the valid centers of the</span>
<span class="sd">    structuring element (the circle).</span>
<span class="sd">    3. The mask is dilated by the structuring element (the circle) to get the final segmentation (the circle opened mask).</span>

<span class="sd">    Args:</span>
<span class="sd">        seg: a 2D numpy array where background is 0 and foreground is &gt; 0</span>
<span class="sd">        labels: list of labels to combine for the circle opening operation</span>
<span class="sd">        radius: the distance from the boundary of the combined labels (corresponds to the radius of the circle)</span>
<span class="sd">    Returns:</span>
<span class="sd">        seg_circle_open: a 2D numpy array where background is 0 and foreground is 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create a mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>

    <span class="c1"># get the distance map</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="c1"># threshold the distance map</span>
    <span class="n">dist_thresh_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">radius</span>

    <span class="c1"># make circular structuring element</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">structure</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># dilate the mask by the threshold</span>
    <span class="n">seg_circle_open</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">dist_thresh_mask</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seg_circle_open</span></div>


    <span class="c1"># find the plane in which the line coordinates are placed</span>


<div class="viewcode-block" id="sphere_opening">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.sphere_opening">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">sphere_opening</span><span class="p">(</span><span class="n">seg</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a segmentation, this function performs a sphere opening operation on the specified labels.</span>
<span class="sd">    The opening operation is performed in 3 steps:</span>
<span class="sd">    1. A mask is created as the union of the specified labels</span>
<span class="sd">    2. The distance map of the mask is calculated and used to threshold the mask such that only the pixels that are</span>
<span class="sd">    at least radius away from the boundary of the mask are kept. This mask corresponds to the valid centers of the</span>
<span class="sd">    structuring element (the sphere).</span>
<span class="sd">    3. The mask is dilated by the structuring element (the sphere) to get the final segmentation (the sphere opened mask).</span>

<span class="sd">    Args:</span>
<span class="sd">        seg: a 3D numpy array where background is 0 and foreground is &gt; 0</span>
<span class="sd">        labels: list of labels to combine for the sphere opening operation</span>
<span class="sd">        radius: the distance from the boundary of the combined labels (corresponds to the radius of the sphere)</span>
<span class="sd">    Returns:</span>
<span class="sd">        seg_open: a 3D numpy array where background is 0 and foreground is 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># create a mask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">seg</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">seg</span> <span class="o">==</span> <span class="n">label</span><span class="p">)</span>

    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>

    <span class="n">dist_thresh_mask</span> <span class="o">=</span> <span class="n">dist</span> <span class="o">&gt;=</span> <span class="n">radius</span>

    <span class="c1"># make spherical structuring element</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">z</span> <span class="o">-</span> <span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">structure</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">radius</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">structure</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># dilate the mask by the threshold</span>
    <span class="n">seg_open</span> <span class="o">=</span> <span class="n">binary_dilation</span><span class="p">(</span><span class="n">dist_thresh_mask</span><span class="p">,</span> <span class="n">structure</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">seg_open</span></div>




<div class="viewcode-block" id="find_plane_of_coords">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.find_plane_of_coords">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_plane_of_coords</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two lines, this function returns the axis of the plane in which the lines are placed.</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list of two lines, where each line is a list of two points with shape (2 lines x 2 points x 3 coordinates)</span>
<span class="sd">    Returns:</span>
<span class="sd">        axis_of_const_coordinate_values: the axis that is perpendicular to the plane in which the lines are placeddinate</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l1p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">l1p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">l2p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">l2p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">const_val</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l1p1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">l1p2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="ow">and</span> <span class="n">l2p1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="n">l2p2</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="n">axis_of_const_coordinate_values</span> <span class="o">=</span> <span class="n">axis</span>
            <span class="n">const_val</span> <span class="o">=</span> <span class="n">l1p1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The lines are not parallel to any of the planes. The coordinates are: </span><span class="se">\n</span><span class="si">{</span><span class="n">coords</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="p">(</span><span class="n">const_val</span><span class="o">.</span><span class="n">is_integer</span><span class="p">()),</span> <span class="sa">f</span><span class="s2">&quot;The constant coordinate value is not an integer: </span><span class="si">{</span><span class="n">const_val</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">return</span> <span class="n">axis_of_const_coordinate_values</span><span class="p">,</span> <span class="n">const_val</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span></div>




<div class="viewcode-block" id="find_closest_plane">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.find_closest_plane">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">find_closest_plane</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two lines, this function returns the axis of the plane in which the lines are placed.</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list of two lines, where each line is a list of two points (2 lines x 2 points x 3 coordinates)</span>
<span class="sd">    Returns:</span>
<span class="sd">        axis_idx: the index of the axis that is perpendicular to the plane in which the lines are placed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">l1p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">l1p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">l2p1</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">l2p2</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="n">l1p2</span> <span class="o">-</span> <span class="n">l1p1</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">l2p2</span> <span class="o">-</span> <span class="n">l2p1</span>

    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>

    <span class="c1"># find the axis with the largest component of the normal</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">normal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">axis_idx</span></div>




<div class="viewcode-block" id="point_closest_to_two_lines">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.point_closest_to_two_lines">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">point_closest_to_two_lines</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given two lines, this function returns the point that is closest to both lines. This can be used to find a point</span>
<span class="sd">    that can be annotated that describes a line pair.</span>

<span class="sd">    Args:</span>
<span class="sd">        coords: a list of two lines, where each line is a list of two points (2 lines x 2 points x 3 coordinates)</span>
<span class="sd">    Returns:</span>
<span class="sd">        closest_point: the point that is closest to both lines</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">p11</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p12</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">p21</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p22</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">e1</span> <span class="o">=</span> <span class="n">p12</span> <span class="o">-</span> <span class="n">p11</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="n">p22</span> <span class="o">-</span> <span class="n">p21</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">normal</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># return the center of all four points</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p11</span> <span class="o">+</span> <span class="n">p12</span> <span class="o">+</span> <span class="n">p21</span> <span class="o">+</span> <span class="n">p22</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="p">(</span><span class="n">p21</span> <span class="o">-</span> <span class="n">p11</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">normal</span><span class="p">),</span> <span class="p">(</span><span class="n">p21</span> <span class="o">-</span> <span class="n">p11</span><span class="p">))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">normal</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
    <span class="n">i1</span> <span class="o">=</span> <span class="n">p11</span> <span class="o">+</span> <span class="n">t1</span> <span class="o">*</span> <span class="n">e1</span>
    <span class="n">i2</span> <span class="o">=</span> <span class="n">p21</span> <span class="o">+</span> <span class="n">t2</span> <span class="o">*</span> <span class="n">e2</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">i1</span> <span class="o">+</span> <span class="n">i2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># if coordinates are larger or smaller than the original coordinates, return the original coordinates</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">coords</span><span class="p">))</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">out</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p11</span> <span class="o">+</span> <span class="n">p12</span> <span class="o">+</span> <span class="n">p21</span> <span class="o">+</span> <span class="n">p22</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span>

    <span class="n">closest_point</span> <span class="o">=</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">closest_point</span></div>



<div class="viewcode-block" id="circle_opening_on_slices_perpendicular_to_axis">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.circle_opening_on_slices_perpendicular_to_axis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">circle_opening_on_slices_perpendicular_to_axis</span><span class="p">(</span><span class="n">segmentationArray</span><span class="p">,</span> <span class="n">axes</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">slice_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a 3D segmentation, this function performs a circle opening operation on the specified labels in the slices</span>
<span class="sd">    perpendicular to each of the specified axes, then returns the union of segmentations from all axes.</span>

<span class="sd">    Args:</span>
<span class="sd">        segmentationArray: a 3D numpy array with the segmentation</span>
<span class="sd">        axes: the axis perpendicular to the slices where the circle opening operation is performed</span>
<span class="sd">        labels: list of labels to combine for the circle opening operation</span>
<span class="sd">        radius: radius of the circle for the circle opening operation</span>
<span class="sd">        slice_idx: if the slice index is specified, the circle opening operation is only performed on that slice. If</span>
<span class="sd">        None, the operation is performed on all slices along the axis. If multiple axes are specified, slice_idx must be</span>
<span class="sd">        a list of the same length as axes.</span>

<span class="sd">    Returns:</span>
<span class="sd">        the circle-opened segmentation along the specified axis</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">segmentationArray</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="n">out_ax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">segmentationArray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">slice_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_idx</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">slice_range</span> <span class="o">=</span> <span class="n">slice_idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">slice_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">slice_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slice_range</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">segmentationArray</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">slc_idx</span> <span class="ow">in</span> <span class="n">slice_range</span><span class="p">:</span>
            <span class="n">slc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">segmentationArray</span><span class="p">,</span> <span class="n">slc_idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">out_slc</span> <span class="o">=</span> <span class="n">circle_opening</span><span class="p">(</span><span class="n">slc</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>

            <span class="c1"># replace the slice in the output with the circle-opened slice  not using np.insert</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="n">slc_idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">out_slc</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="n">slc_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">out_slc</span>
            <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">slc_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">out_slc</span>

        <span class="c1"># combine output with the previous outputs</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">out_ax</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">segmentationArray</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out</span></div>




<div class="viewcode-block" id="get_ijk_to_world_matrix">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.get_ijk_to_world_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">get_ijk_to_world_matrix</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a node, this function returns the IJK to world matrix of the binary labelmap</span>

<span class="sd">    Args:</span>
<span class="sd">        node: the segmentation node or volume node</span>

<span class="sd">    Returns:</span>
<span class="sd">        ijkToWorld: the IJK to world matrix of the binary labelmap</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">binaryLabelmapRepresentation</span> <span class="o">=</span> <span class="n">slicer</span><span class="o">.</span><span class="n">vtkOrientedImageData</span><span class="p">()</span>

    <span class="n">ijkToWorld</span> <span class="o">=</span> <span class="n">vtk</span><span class="o">.</span><span class="n">vtkMatrix4x4</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">IsA</span><span class="p">(</span><span class="s2">&quot;vtkMRMLSegmentationNode&quot;</span><span class="p">):</span>
        <span class="n">segmentId</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">GetSegmentation</span><span class="p">()</span><span class="o">.</span><span class="n">GetSegmentIDs</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">node</span><span class="o">.</span><span class="n">GetBinaryLabelmapRepresentation</span><span class="p">(</span><span class="n">segmentId</span><span class="p">,</span> <span class="n">binaryLabelmapRepresentation</span><span class="p">)</span>
        <span class="n">binaryLabelmapRepresentation</span><span class="o">.</span><span class="n">GetImageToWorldMatrix</span><span class="p">(</span><span class="n">ijkToWorld</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">IsA</span><span class="p">(</span><span class="s2">&quot;vtkMRMLScalarVolumeNode&quot;</span><span class="p">):</span>
            <span class="n">node</span><span class="o">.</span><span class="n">GetIJKToRASMatrix</span><span class="p">(</span><span class="n">ijkToWorld</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Node must be a segmentation node or a volume node&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ijkToWorld</span></div>




<div class="viewcode-block" id="transform_ijk_to_world_coord">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.transform_ijk_to_world_coord">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_ijk_to_world_coord</span><span class="p">(</span><span class="n">ijk</span><span class="p">,</span> <span class="n">ijkToWorld_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an IJK coordinate and the IJK to world matrix, this function returns the world coordinate</span>

<span class="sd">    Args:</span>
<span class="sd">        ijk: the IJK coordinates (x, y, z)</span>
<span class="sd">        ijkToWorld_matrix: the IJK to world matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        the world coordinate (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_idx</span><span class="p">,</span> <span class="n">y_idx</span><span class="p">,</span> <span class="n">z_idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># swap z and x from numpy to slicer</span>
    <span class="k">return</span> <span class="n">ijkToWorld_matrix</span><span class="o">.</span><span class="n">MultiplyPoint</span><span class="p">([</span><span class="n">ijk</span><span class="p">[</span><span class="n">x_idx</span><span class="p">],</span> <span class="n">ijk</span><span class="p">[</span><span class="n">y_idx</span><span class="p">],</span> <span class="n">ijk</span><span class="p">[</span><span class="n">z_idx</span><span class="p">],</span> <span class="mi">1</span><span class="p">])[</span>
           <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># [:3] to remove the homogeneous coordinate (1)</span></div>


<div class="viewcode-block" id="transform_ijk_to_world_coord_np">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.transform_ijk_to_world_coord_np">[docs]</a>
<span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_ijk_to_world_coord_np</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">ijkToWorld_np</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform a coordinate from IJK to world space using the ijkToWorld matrix given as a numpy array.</span>

<span class="sd">    Args:</span>
<span class="sd">        coord: the IJK coordinates (x, y, z)</span>
<span class="sd">        ijkToWorld_np: the IJK to world matrix as a numpy array</span>

<span class="sd">    Returns:</span>
<span class="sd">        the world coordinate (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x_idx</span><span class="p">,</span> <span class="n">y_idx</span><span class="p">,</span> <span class="n">z_idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span>  <span class="c1"># swap z and x from numpy to slicer</span>

    <span class="c1"># matrix multiplication replicating np.dot(ijkToWorld_np, np.array([coord[x_idx], coord[y_idx], coord[z_idx], 1]))</span>
    <span class="n">world</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">mat</span> <span class="o">=</span> <span class="n">ijkToWorld_np</span>
    <span class="n">vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">coord</span><span class="p">[</span><span class="n">x_idx</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="n">y_idx</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="n">z_idx</span><span class="p">],</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>  <span class="c1"># 3D coordinates, remove the homogeneous coordinate (1)</span>
        <span class="n">world</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">vec</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="c1">#world = np.dot(ijkToWorld_np, np.array([coord[x_idx], coord[y_idx], coord[z_idx], 1]))[:3]</span>
    <span class="k">return</span> <span class="n">world</span></div>




<div class="viewcode-block" id="transform_world_to_ijk_coord">
<a class="viewcode-back" href="../../utils.rano_utils.html#utils.rano_utils.transform_world_to_ijk_coord">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">transform_world_to_ijk_coord</span><span class="p">(</span><span class="n">world</span><span class="p">,</span> <span class="n">worldToIJK_matrix</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a world coordinate and the world to IJK matrix, this function returns the IJK coordinate</span>

<span class="sd">    Args:</span>
<span class="sd">        world: the world coordinates (x, y, z)</span>
<span class="sd">        worldToIJK_matrix: the world to IJK matrix</span>

<span class="sd">    Returns:</span>
<span class="sd">        the IJK coordinate (x, y, z)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kji</span> <span class="o">=</span> <span class="n">worldToIJK_matrix</span><span class="o">.</span><span class="n">MultiplyPoint</span><span class="p">([</span><span class="n">world</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">world</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">world</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">])[</span>
          <span class="p">:</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># [:3] to remove the homogeneous coordinate (1)</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">kji</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">kji</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">kji</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>  <span class="c1"># swap z and x from slicer</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Aaron Kujawa.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>